<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core3D: HArDCore3D::HybridCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core3D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 3D - Library to implement 3D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>HArDCore3D</b></li><li class="navelem"><a class="el" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classHArDCore3D_1_1HybridCore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HArDCore3D::HybridCore Class Reference<div class="ingroups"><a class="el" href="group__HybridCore.html">HybridCore</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="hybridcore_8hpp_source.html">hybridcore.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9e760b418a3948b34114879f37086829"><td class="memItemLeft" align="right" valign="top"><a id="a9e760b418a3948b34114879f37086829"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a9e760b418a3948b34114879f37086829">cell_basis_type</a> = std::function&lt; double(double, double, double)&gt;</td></tr>
<tr class="memdesc:a9e760b418a3948b34114879f37086829"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for cell basis <br /></td></tr>
<tr class="separator:a9e760b418a3948b34114879f37086829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dd9ca67d6de59d7ea71c816d3d3e67"><td class="memItemLeft" align="right" valign="top"><a id="ad4dd9ca67d6de59d7ea71c816d3d3e67"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#ad4dd9ca67d6de59d7ea71c816d3d3e67">cell_gradient_type</a> = std::function&lt; Eigen::Vector3d(double, double, double)&gt;</td></tr>
<tr class="memdesc:ad4dd9ca67d6de59d7ea71c816d3d3e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for gradients of cell basis <br /></td></tr>
<tr class="separator:ad4dd9ca67d6de59d7ea71c816d3d3e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b0cdad94d3527d0b06e601c091cdad"><td class="memItemLeft" align="right" valign="top"><a id="ae0b0cdad94d3527d0b06e601c091cdad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#ae0b0cdad94d3527d0b06e601c091cdad">face_basis_type</a> = std::function&lt; double(double, double, double)&gt;</td></tr>
<tr class="memdesc:ae0b0cdad94d3527d0b06e601c091cdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for face basis <br /></td></tr>
<tr class="separator:ae0b0cdad94d3527d0b06e601c091cdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e174245a6104913a2272e7fe96db46"><td class="memItemLeft" align="right" valign="top"><a id="ae3e174245a6104913a2272e7fe96db46"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#ae3e174245a6104913a2272e7fe96db46">tensor_function_type</a> = std::function&lt; Eigen::Matrix3d(double, double, double)&gt;</td></tr>
<tr class="memdesc:ae3e174245a6104913a2272e7fe96db46"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for 3D tensors basis <br /></td></tr>
<tr class="separator:ae3e174245a6104913a2272e7fe96db46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af4978b5ad1f20f152357e94ffa94bfa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#af4978b5ad1f20f152357e94ffa94bfa9">HybridCore</a> (const <a class="el" href="classHArDCore3D_1_1Mesh.html">Mesh</a> *mesh_ptr, const size_t <a class="el" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>, const size_t <a class="el" href="group__HybridCore.html#gae2bb060c207a888bf97a9d2a9626e1c0">L</a>, const std::string choice_basis=&quot;Mon&quot;)</td></tr>
<tr class="memdesc:af4978b5ad1f20f152357e94ffa94bfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions.  <a href="#af4978b5ad1f20f152357e94ffa94bfa9">More...</a><br /></td></tr>
<tr class="separator:af4978b5ad1f20f152357e94ffa94bfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bdc59d150566e1b992058031509d2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#aa2bdc59d150566e1b992058031509d2f">dim_Pcell</a> (const size_t m) const</td></tr>
<tr class="memdesc:aa2bdc59d150566e1b992058031509d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 3-variate polynomials up to degree m.  <a href="#aa2bdc59d150566e1b992058031509d2f">More...</a><br /></td></tr>
<tr class="separator:aa2bdc59d150566e1b992058031509d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d3a5aa6d681847e90c41d91abb360e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a52d3a5aa6d681847e90c41d91abb360e">dim_Pface</a> (const size_t m) const</td></tr>
<tr class="memdesc:a52d3a5aa6d681847e90c41d91abb360e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 1-variate polynomials up to degree m.  <a href="#a52d3a5aa6d681847e90c41d91abb360e">More...</a><br /></td></tr>
<tr class="separator:a52d3a5aa6d681847e90c41d91abb360e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7006921a9e212784abf688f63a855a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#a9e760b418a3948b34114879f37086829">cell_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#aa7006921a9e212784abf688f63a855a0">cell_monomial</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:aa7006921a9e212784abf688f63a855a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th monomial function of the cell iT.  <a href="#aa7006921a9e212784abf688f63a855a0">More...</a><br /></td></tr>
<tr class="separator:aa7006921a9e212784abf688f63a855a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4544ebe6193ab5239fdca5381043c031"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ae0b0cdad94d3527d0b06e601c091cdad">face_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a4544ebe6193ab5239fdca5381043c031">face_monomial</a> (size_t iF, size_t i) const</td></tr>
<tr class="memdesc:a4544ebe6193ab5239fdca5381043c031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th monomial function of the face iF.  <a href="#a4544ebe6193ab5239fdca5381043c031">More...</a><br /></td></tr>
<tr class="separator:a4544ebe6193ab5239fdca5381043c031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34242db07cc2b3c3b867d9e4580b634d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#a9e760b418a3948b34114879f37086829">cell_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">cell_basis</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:a34242db07cc2b3c3b867d9e4580b634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th basis function of the cell iT.  <a href="#a34242db07cc2b3c3b867d9e4580b634d">More...</a><br /></td></tr>
<tr class="separator:a34242db07cc2b3c3b867d9e4580b634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bacf0ebee651940baa7f04af5a47b65"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ae0b0cdad94d3527d0b06e601c091cdad">face_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a7bacf0ebee651940baa7f04af5a47b65">face_basis</a> (size_t iF, size_t i) const</td></tr>
<tr class="memdesc:a7bacf0ebee651940baa7f04af5a47b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th basis function of the face iF.  <a href="#a7bacf0ebee651940baa7f04af5a47b65">More...</a><br /></td></tr>
<tr class="separator:a7bacf0ebee651940baa7f04af5a47b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edb2fb02577f68744abb8a436381cf7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ad4dd9ca67d6de59d7ea71c816d3d3e67">cell_gradient_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a0edb2fb02577f68744abb8a436381cf7">cell_monomials_gradient</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:a0edb2fb02577f68744abb8a436381cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the gradient of the i'th monomial function of the cell iT.  <a href="#a0edb2fb02577f68744abb8a436381cf7">More...</a><br /></td></tr>
<tr class="separator:a0edb2fb02577f68744abb8a436381cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710fc23b914623b90a2699ab4291e539"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ad4dd9ca67d6de59d7ea71c816d3d3e67">cell_gradient_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a710fc23b914623b90a2699ab4291e539">cell_gradient</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:a710fc23b914623b90a2699ab4291e539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the gradient of the i'th basis function of the celliT.  <a href="#a710fc23b914623b90a2699ab4291e539">More...</a><br /></td></tr>
<tr class="separator:a710fc23b914623b90a2699ab4291e539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b46a742045262030431b73eb112f9c"><td class="memItemLeft" align="right" valign="top"><a id="a02b46a742045262030431b73eb112f9c"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a02b46a742045262030431b73eb112f9c">restr</a> (const Eigen::VectorXd &amp;Xh, size_t iT) const</td></tr>
<tr class="memdesc:a02b46a742045262030431b73eb112f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from a global vector Xh of unknowns the unknowns corresponding to cell iT. <br /></td></tr>
<tr class="separator:a02b46a742045262030431b73eb112f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2a3d4fde899dde50fda5d97eafdc07"><td class="memItemLeft" align="right" valign="top"><a id="a6c2a3d4fde899dde50fda5d97eafdc07"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a6c2a3d4fde899dde50fda5d97eafdc07">L2norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:a6c2a3d4fde899dde50fda5d97eafdc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L2 norm of a discrete function (using cell values) <br /></td></tr>
<tr class="separator:a6c2a3d4fde899dde50fda5d97eafdc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962007697ffc13367070f7c4bcbe875"><td class="memItemLeft" align="right" valign="top"><a id="a5962007697ffc13367070f7c4bcbe875"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a5962007697ffc13367070f7c4bcbe875">H1norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:a5962007697ffc13367070f7c4bcbe875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute discrete H1 norm of a discrete function (using cell values) <br /></td></tr>
<tr class="separator:a5962007697ffc13367070f7c4bcbe875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333758d69cc0cea9df7bd54042551504"><td class="memItemLeft" align="right" valign="top"><a id="a333758d69cc0cea9df7bd54042551504"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a333758d69cc0cea9df7bd54042551504">Linf_face</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:a333758d69cc0cea9df7bd54042551504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximum of the coefficients on the face basis functions. <br /></td></tr>
<tr class="separator:a333758d69cc0cea9df7bd54042551504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c3baf0764f3f160759e0ffc8969dfb"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gaa1c3baf0764f3f160759e0ffc8969dfb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaa1c3baf0764f3f160759e0ffc8969dfb">interpolate</a> (const Function &amp;f, size_t doe) const</td></tr>
<tr class="memdesc:gaa1c3baf0764f3f160759e0ffc8969dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolant in the discrete space of a continuous function.  <a href="group__HybridCore.html#gaa1c3baf0764f3f160759e0ffc8969dfb">More...</a><br /></td></tr>
<tr class="separator:gaa1c3baf0764f3f160759e0ffc8969dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c203c11a661933930a33335b0e2479"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a> (const std::vector&lt; Eigen::ArrayXd &gt; &amp;f_quad, const std::vector&lt; Eigen::ArrayXd &gt; &amp;g_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; double &gt; L2weight={}) const</td></tr>
<tr class="separator:aa5c203c11a661933930a33335b0e2479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7403a7f6890fc8ffae6f8dc531c1b397"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a7403a7f6890fc8ffae6f8dc531c1b397">gram_matrix</a> (const std::vector&lt; Eigen::ArrayXXd &gt; &amp;F_quad, const std::vector&lt; Eigen::ArrayXXd &gt; &amp;G_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; Eigen::Matrix3d &gt; L2Weight={}) const</td></tr>
<tr class="memdesc:a7403a7f6890fc8ffae6f8dc531c1b397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded version of the previous one for vector-valued functions: the functions (F_i) and (G_j) are vector-valued functions.  <a href="#a7403a7f6890fc8ffae6f8dc531c1b397">More...</a><br /></td></tr>
<tr class="separator:a7403a7f6890fc8ffae6f8dc531c1b397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06825c5d156026d465a2798389aa952b"><td class="memItemLeft" align="right" valign="top"><a id="a06825c5d156026d465a2798389aa952b"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a06825c5d156026d465a2798389aa952b">compute_weights</a> (size_t iT) const</td></tr>
<tr class="memdesc:a06825c5d156026d465a2798389aa952b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights to compute cell unknowns from face unknowns when l=-1. <br /></td></tr>
<tr class="separator:a06825c5d156026d465a2798389aa952b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36cb92e3054b15c3b5b10fead49e925"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::ArrayXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#af36cb92e3054b15c3b5b10fead49e925">basis_quad</a> (const std::string cellface, const size_t iTF, const QuadratureRule quad, const size_t degree, const std::string type_basis=&quot;basis&quot;) const</td></tr>
<tr class="memdesc:af36cb92e3054b15c3b5b10fead49e925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (cell or face) basis functions at the given quadrature nodes.  <a href="#af36cb92e3054b15c3b5b10fead49e925">More...</a><br /></td></tr>
<tr class="separator:af36cb92e3054b15c3b5b10fead49e925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add794287f4bb49157a7b5f94a5ecb200"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::ArrayXXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#add794287f4bb49157a7b5f94a5ecb200">grad_basis_quad</a> (const size_t iT, const QuadratureRule quad, const size_t degree, const std::string type_basis=&quot;basis&quot;) const</td></tr>
<tr class="memdesc:add794287f4bb49157a7b5f94a5ecb200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$(\nabla \phi_i)_{i\in I}$" src="form_11.png"/> at the given quadrature nodes, where <img class="formulaInl" alt="$(\phi_i)_{i\in I}$" src="form_12.png"/> are the cell basis functions.  <a href="#add794287f4bb49157a7b5f94a5ecb200">More...</a><br /></td></tr>
<tr class="separator:add794287f4bb49157a7b5f94a5ecb200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e0febebb2735a8cc7017873683b611"><td class="memItemLeft" align="right" valign="top"><a id="a19e0febebb2735a8cc7017873683b611"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a19e0febebb2735a8cc7017873683b611">evaluate_in_cell</a> (const Eigen::VectorXd XTF, size_t iT, double x, double y, double z) const</td></tr>
<tr class="memdesc:a19e0febebb2735a8cc7017873683b611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function in the cell iT at point (x,y,z) <br /></td></tr>
<tr class="separator:a19e0febebb2735a8cc7017873683b611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7364c571c3ecadb5a7025047478b3e40"><td class="memItemLeft" align="right" valign="top"><a id="a7364c571c3ecadb5a7025047478b3e40"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a7364c571c3ecadb5a7025047478b3e40">evaluate_in_face</a> (const Eigen::VectorXd XTF, size_t iF, double x, double y, double z) const</td></tr>
<tr class="memdesc:a7364c571c3ecadb5a7025047478b3e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function on the face iF at point (x,y,z) <br /></td></tr>
<tr class="separator:a7364c571c3ecadb5a7025047478b3e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4c32f117a1e67ec4a13dd9656c404e8"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classHArDCore3D_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gad4c32f117a1e67ec4a13dd9656c404e8">get_mesh_ptr</a> () const</td></tr>
<tr class="memdesc:gad4c32f117a1e67ec4a13dd9656c404e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to the mesh <br /></td></tr>
<tr class="separator:gad4c32f117a1e67ec4a13dd9656c404e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c5d20faf615bca6e170961a61464fb2"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a> () const</td></tr>
<tr class="memdesc:ga5c5d20faf615bca6e170961a61464fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial degree of edge unknowns <br /></td></tr>
<tr class="separator:ga5c5d20faf615bca6e170961a61464fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2bb060c207a888bf97a9d2a9626e1c0"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gae2bb060c207a888bf97a9d2a9626e1c0">L</a> () const</td></tr>
<tr class="memdesc:gae2bb060c207a888bf97a9d2a9626e1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial degree of cell unknowns <br /></td></tr>
<tr class="separator:gae2bb060c207a888bf97a9d2a9626e1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907fd6e5325465e94acc67c831a14cdf"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga907fd6e5325465e94acc67c831a14cdf">Ldeg</a> () const</td></tr>
<tr class="memdesc:ga907fd6e5325465e94acc67c831a14cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">usually equal to L, but put at 0 if L=-1 <br /></td></tr>
<tr class="separator:ga907fd6e5325465e94acc67c831a14cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804722e06e20a32477cd1ae41ee6f473"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga804722e06e20a32477cd1ae41ee6f473">ntotal_dofs</a> () const</td></tr>
<tr class="memdesc:ga804722e06e20a32477cd1ae41ee6f473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of degrees of freedom. <br /></td></tr>
<tr class="separator:ga804722e06e20a32477cd1ae41ee6f473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228678f9bf8057025f3c220e40cab209"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a> () const</td></tr>
<tr class="memdesc:ga228678f9bf8057025f3c220e40cab209"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of degrees of freedom in each cell (dimension of polynomial space) <br /></td></tr>
<tr class="separator:ga228678f9bf8057025f3c220e40cab209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae30736925e857cb467c3f5c75fdc97e"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaae30736925e857cb467c3f5c75fdc97e">ntotal_cell_dofs</a> () const</td></tr>
<tr class="memdesc:gaae30736925e857cb467c3f5c75fdc97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of cell degrees of freedom <br /></td></tr>
<tr class="separator:gaae30736925e857cb467c3f5c75fdc97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fa97198237f40a378a384f3d072394"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a> () const</td></tr>
<tr class="memdesc:ga94fa97198237f40a378a384f3d072394"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of degrees of freedom on each face (dimension of polynomial space) <br /></td></tr>
<tr class="separator:ga94fa97198237f40a378a384f3d072394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2e20ded434d1aacc44927934faabc1c"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gab2e20ded434d1aacc44927934faabc1c">ntotal_face_dofs</a> () const</td></tr>
<tr class="memdesc:gab2e20ded434d1aacc44927934faabc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of face degrees of freedom <br /></td></tr>
<tr class="separator:gab2e20ded434d1aacc44927934faabc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffef0ee3517c408e3d086956feb022bd"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaffef0ee3517c408e3d086956feb022bd">ninternal_face_dofs</a> () const</td></tr>
<tr class="memdesc:gaffef0ee3517c408e3d086956feb022bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of face degrees of freedom for internal faces <br /></td></tr>
<tr class="separator:gaffef0ee3517c408e3d086956feb022bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddeb59cc8b5d89525e27b2dee22eb70f"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaddeb59cc8b5d89525e27b2dee22eb70f">nboundary_face_dofs</a> () const</td></tr>
<tr class="memdesc:gaddeb59cc8b5d89525e27b2dee22eb70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of face degrees of freedom for boundary faces <br /></td></tr>
<tr class="separator:gaddeb59cc8b5d89525e27b2dee22eb70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b815b769bba05753666f6bf900fdc5"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a> () const</td></tr>
<tr class="memdesc:ga07b815b769bba05753666f6bf900fdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of cell degrees of freedom with polynomials up to order k+1 <br /></td></tr>
<tr class="separator:ga07b815b769bba05753666f6bf900fdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0fe217b02f8b2c132f6917e2ac9900"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga3b0fe217b02f8b2c132f6917e2ac9900">ngradient_dofs</a> () const</td></tr>
<tr class="memdesc:ga3b0fe217b02f8b2c132f6917e2ac9900"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of degrees of freedom for gradients <br /></td></tr>
<tr class="separator:ga3b0fe217b02f8b2c132f6917e2ac9900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca6e3380063a17fcb76276bc8c503d5b"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gaca6e3380063a17fcb76276bc8c503d5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaca6e3380063a17fcb76276bc8c503d5b">quadrature_over_cell</a> (const size_t iT, const Function &amp;f) const</td></tr>
<tr class="memdesc:gaca6e3380063a17fcb76276bc8c503d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">To integrate a function over a cell. <br /></td></tr>
<tr class="separator:gaca6e3380063a17fcb76276bc8c503d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabba9f8c9be9f2006a441304054b955c6"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gabba9f8c9be9f2006a441304054b955c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gabba9f8c9be9f2006a441304054b955c6">quadrature_over_face</a> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="memdesc:gabba9f8c9be9f2006a441304054b955c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">To integrate a function over a face. <br /></td></tr>
<tr class="separator:gabba9f8c9be9f2006a441304054b955c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb893746a3e8bdb80500be5c9382d96"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga1cb893746a3e8bdb80500be5c9382d96"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga1cb893746a3e8bdb80500be5c9382d96">integrate_over_cell</a> (const size_t iT, const Function &amp;f) const</td></tr>
<tr class="memdesc:ga1cb893746a3e8bdb80500be5c9382d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a function over a cell. Use with parcimony, expensive (re-compute quadratures) <br /></td></tr>
<tr class="separator:ga1cb893746a3e8bdb80500be5c9382d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6ad78c453a5a5ec6bc91d7a14e4c2a"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gacb6ad78c453a5a5ec6bc91d7a14e4c2a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gacb6ad78c453a5a5ec6bc91d7a14e4c2a">integrate_over_face</a> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="memdesc:gacb6ad78c453a5a5ec6bc91d7a14e4c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a function over a face. Use with parcimony, expensive (re-compute quadratures) <br /></td></tr>
<tr class="separator:gacb6ad78c453a5a5ec6bc91d7a14e4c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6aeaa4f65c67b92307c273254f539ed"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gad6aeaa4f65c67b92307c273254f539ed"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gad6aeaa4f65c67b92307c273254f539ed">integrate_over_domain</a> (const Function &amp;f) const</td></tr>
<tr class="memdesc:gad6aeaa4f65c67b92307c273254f539ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a function over the domaine. Use with parcimony, expensive (re-compute quadratures) <br /></td></tr>
<tr class="separator:gad6aeaa4f65c67b92307c273254f539ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e623d59fe09c23c4b714541e4aff5ea"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a4e623d59fe09c23c4b714541e4aff5ea">VertexValues</a> (const Eigen::VectorXd Xh, const std::string from_dofs)</td></tr>
<tr class="memdesc:a4e623d59fe09c23c4b714541e4aff5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a hybrid function, computes a vector of values at the vertices of the mesh.  <a href="#a4e623d59fe09c23c4b714541e4aff5ea">More...</a><br /></td></tr>
<tr class="separator:a4e623d59fe09c23c4b714541e4aff5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a> class provides convenient interfaces for performing integration over mesh cells and faces and handling polynomial basis functionsThe class also provides convenient interfaces for dealing with solutions to Hybrid High-Order schemes, such as the computation of integrals, norms and interpolants in the HHO space. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af4978b5ad1f20f152357e94ffa94bfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4978b5ad1f20f152357e94ffa94bfa9">&#9670;&nbsp;</a></span>HybridCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HybridCore::HybridCore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore3D_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>choice_basis</em> = <code>&quot;Mon&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions. </p>
<p>The orthonormalisation comes at a cost in terms of manipulation of the basis functions. This should only be use when the polynomial degree is large and/or the cell is very distorted. However, in these cases, it can make a huge difference on the observed convergence rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_ptr</td><td>A pointer to the loaded mesh </td></tr>
    <tr><td class="paramname">K</td><td>The degree of the face polynomials </td></tr>
    <tr><td class="paramname">L</td><td>The degree of the cell polynomials </td></tr>
    <tr><td class="paramname">choice_basis</td><td>"Mon" for monomials basis, "ON" for orthonormalised basis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af36cb92e3054b15c3b5b10fead49e925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36cb92e3054b15c3b5b10fead49e925">&#9670;&nbsp;</a></span>basis_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; Eigen::ArrayXd &gt; HybridCore::basis_quad </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>cellface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iTF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>type_basis</em> = <code>&quot;basis&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes (cell or face) basis functions at the given quadrature nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>phi_quad[i] = array listing the nbq (=nb of quadrature nodes) values of phi_i at the quadrature nodes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellface</td><td>determines the type of basis function (cell or face) we want the values of </td></tr>
    <tr><td class="paramname">iTF</td><td>global index of the cell/face </td></tr>
    <tr><td class="paramname">quad</td><td>quadrature nodes and weights on the cell/face </td></tr>
    <tr><td class="paramname">degree</td><td>the maximum polynomial degree to consider </td></tr>
    <tr><td class="paramname">type_basis</td><td>optional argument to determine if we want on the monomial, or the basis functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34242db07cc2b3c3b867d9e4580b634d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34242db07cc2b3c3b867d9e4580b634d">&#9670;&nbsp;</a></span>cell_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#a9e760b418a3948b34114879f37086829">HybridCore::cell_basis_type</a> &amp; HybridCore::cell_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th basis function of the cell iT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global cell number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710fc23b914623b90a2699ab4291e539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710fc23b914623b90a2699ab4291e539">&#9670;&nbsp;</a></span>cell_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ad4dd9ca67d6de59d7ea71c816d3d3e67">HybridCore::cell_gradient_type</a> &amp; HybridCore::cell_gradient </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the gradient of the i'th basis function of the celliT. </p>
<p>Note that the gradient functions are indexed the same as the basis functions. In particular, this means that the first gradient function will always be identically zero, as it is the gradient of the constant basis function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global cell number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7006921a9e212784abf688f63a855a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7006921a9e212784abf688f63a855a0">&#9670;&nbsp;</a></span>cell_monomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#a9e760b418a3948b34114879f37086829">HybridCore::cell_basis_type</a> &amp; HybridCore::cell_monomial </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th monomial function of the cell iT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global cell number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired monomial function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0edb2fb02577f68744abb8a436381cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edb2fb02577f68744abb8a436381cf7">&#9670;&nbsp;</a></span>cell_monomials_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ad4dd9ca67d6de59d7ea71c816d3d3e67">HybridCore::cell_gradient_type</a> &amp; HybridCore::cell_monomials_gradient </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the gradient of the i'th monomial function of the cell iT. </p>
<p>Note that the gradient functions are indexed the same as the monomial functions. In particular, this means that the first gradient function will always be identically zero, as it is the gradient of the constant monomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global cell number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired monomial function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2bdc59d150566e1b992058031509d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bdc59d150566e1b992058031509d2f">&#9670;&nbsp;</a></span>dim_Pcell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HybridCore::dim_Pcell </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 3-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52d3a5aa6d681847e90c41d91abb360e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d3a5aa6d681847e90c41d91abb360e">&#9670;&nbsp;</a></span>dim_Pface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HybridCore::dim_Pface </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 1-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bacf0ebee651940baa7f04af5a47b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bacf0ebee651940baa7f04af5a47b65">&#9670;&nbsp;</a></span>face_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ae0b0cdad94d3527d0b06e601c091cdad">HybridCore::face_basis_type</a> &amp; HybridCore::face_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th basis function of the face iF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iF</td><td>The global face number of the face </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4544ebe6193ab5239fdca5381043c031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4544ebe6193ab5239fdca5381043c031">&#9670;&nbsp;</a></span>face_monomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ae0b0cdad94d3527d0b06e601c091cdad">HybridCore::face_basis_type</a> &amp; HybridCore::face_monomial </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th monomial function of the face iF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iF</td><td>The global number of the face </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired monomial function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add794287f4bb49157a7b5f94a5ecb200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add794287f4bb49157a7b5f94a5ecb200">&#9670;&nbsp;</a></span>grad_basis_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; Eigen::ArrayXXd &gt; HybridCore::grad_basis_quad </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>type_basis</em> = <code>&quot;basis&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute <img class="formulaInl" alt="$(\nabla \phi_i)_{i\in I}$" src="form_11.png"/> at the given quadrature nodes, where <img class="formulaInl" alt="$(\phi_i)_{i\in I}$" src="form_12.png"/> are the cell basis functions. </p>
<dl class="section return"><dt>Returns</dt><dd>dphi_quad[i]: array of size 3*nbq (where nbq=nb of quadrature nodes), with each column being <img class="formulaInl" alt="$\nabla \phi_i$" src="form_13.png"/> at the corresponding quadrature node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>global index of the cell </td></tr>
    <tr><td class="paramname">quad</td><td>quadrature rules in the cell </td></tr>
    <tr><td class="paramname">degree</td><td>the maximum polynomial degree to consider </td></tr>
    <tr><td class="paramname">type_basis</td><td>optional argument to determine if we want on the monomial, or the basis functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5c203c11a661933930a33335b0e2479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c203c11a661933930a33335b0e2479">&#9670;&nbsp;</a></span>gram_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HybridCore::gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>L2weight</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the matrix of L2 products of two families (f_i) and (g_j) of functions (this is not really a Gram matrix, unless the two families are the same) </p><dl class="section return"><dt>Returns</dt><dd>The matrix <img class="formulaInl" alt="$(\int f_i g_j)_{i=1\ldots nrows; j=1\ldots ncols}$" src="form_9.png"/> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_quad</td><td>Values of functions (f1,f2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">g_quad</td><td>Values of functions (g1,g2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix - typically number of functions f_i (but could be less) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns of the matrix - typically number of functions g_j (but could be less) </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature nodes for integration </td></tr>
    <tr><td class="paramname">sym</td><td>True if the matrix is pseudo-symmetric (that is, #f&lt;=#g and f_i=g_i if i&lt;=#f) </td></tr>
    <tr><td class="paramname">L2weight</td><td>Optional weight for the L2 product. If provided, should be a std::vector&lt;double&gt; of the weight at the quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7403a7f6890fc8ffae6f8dc531c1b397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7403a7f6890fc8ffae6f8dc531c1b397">&#9670;&nbsp;</a></span>gram_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HybridCore::gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>G_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix3d &gt;&#160;</td>
          <td class="paramname"><em>L2Weight</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded version of the previous one for vector-valued functions: the functions (F_i) and (G_j) are vector-valued functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The matrix <img class="formulaInl" alt="$(\int F_i \cdot G_j)_{i=1\ldots nrows; j=1\ldots ncols}$" src="form_10.png"/> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F_quad</td><td>Values of functions (F1,F2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">G_quad</td><td>Values of functions (G1,G2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix - typically number of functions F_i (but could be less) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of rows of the matrix - typically number of functions G_j (but could be less) </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature nodes for integration </td></tr>
    <tr><td class="paramname">sym</td><td>True if the matrix is pseudo-symmetric (that is, #F&lt;=#G and F_i=G_i if i&lt;=#F) </td></tr>
    <tr><td class="paramname">L2Weight</td><td>Optional weight for the L2 product. If provided, should be a std::vector&lt;Eigen::Matrix3d&gt; of the weight at the quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e623d59fe09c23c4b714541e4aff5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e623d59fe09c23c4b714541e4aff5ea">&#9670;&nbsp;</a></span>VertexValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HybridCore::VertexValues </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd&#160;</td>
          <td class="paramname"><em>Xh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>from_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From a hybrid function, computes a vector of values at the vertices of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Xh</td><td>hybrid function (cell and face polynomials) </td></tr>
    <tr><td class="paramname">from_dofs</td><td>Type of unknowns to use: "cell" or "face" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/HybridCore/<a class="el" href="hybridcore_8hpp_source.html">hybridcore.hpp</a></li>
<li>src/HybridCore/hybridcore.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
