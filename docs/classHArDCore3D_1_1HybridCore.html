<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core3D: HArDCore3D::HybridCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core3D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 3D - Library to implement 3D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>HArDCore3D</b></li><li class="navelem"><a class="el" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classHArDCore3D_1_1HybridCore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HArDCore3D::HybridCore Class Reference<div class="ingroups"><a class="el" href="group__HybridCore.html">HybridCore</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="hybridcore_8hpp_source.html">hybridcore.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5c478c9953257f154d2ea98f115fba0d"><td class="memItemLeft" align="right" valign="top"><a id="a5c478c9953257f154d2ea98f115fba0d"></a>
typedef <a class="el" href="classHArDCore3D_1_1Family.html">Family</a>&lt; <a class="el" href="classHArDCore3D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a5c478c9953257f154d2ea98f115fba0d">PolyCellBasisType</a></td></tr>
<tr class="memdesc:a5c478c9953257f154d2ea98f115fba0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for cell basis <br /></td></tr>
<tr class="separator:a5c478c9953257f154d2ea98f115fba0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02b7a4490b6a739e2d084e9a70dbcc5"><td class="memItemLeft" align="right" valign="top"><a id="ab02b7a4490b6a739e2d084e9a70dbcc5"></a>
typedef <a class="el" href="classHArDCore3D_1_1Family.html">Family</a>&lt; <a class="el" href="classHArDCore3D_1_1MonomialScalarBasisFace.html">MonomialScalarBasisFace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#ab02b7a4490b6a739e2d084e9a70dbcc5">PolyFaceBasisType</a></td></tr>
<tr class="memdesc:ab02b7a4490b6a739e2d084e9a70dbcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for face basis <br /></td></tr>
<tr class="separator:ab02b7a4490b6a739e2d084e9a70dbcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3123dceabd79eec7cdb57ba1014fc17"><td class="memItemLeft" align="right" valign="top"><a id="ad3123dceabd79eec7cdb57ba1014fc17"></a>
typedef <a class="el" href="classHArDCore3D_1_1Family.html">Family</a>&lt; <a class="el" href="classHArDCore3D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#ad3123dceabd79eec7cdb57ba1014fc17">PolyEdgeBasisType</a></td></tr>
<tr class="memdesc:ad3123dceabd79eec7cdb57ba1014fc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for edge basis <br /></td></tr>
<tr class="separator:ad3123dceabd79eec7cdb57ba1014fc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af74bfd2755cae90735669032bec84918"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#af74bfd2755cae90735669032bec84918">HybridCore</a> (const <a class="el" href="classHArDCore3D_1_1Mesh.html">Mesh</a> *mesh_ptr, const int cell_deg, const size_t face_deg, const int edge_deg, const bool use_threads=true, std::ostream &amp;output=std::cout)</td></tr>
<tr class="memdesc:af74bfd2755cae90735669032bec84918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions.  <a href="#af74bfd2755cae90735669032bec84918">More...</a><br /></td></tr>
<tr class="separator:af74bfd2755cae90735669032bec84918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9413be657df06123c1544d16df6b137"><td class="memItemLeft" align="right" valign="top"><a id="af9413be657df06123c1544d16df6b137"></a>
const <a class="el" href="classHArDCore3D_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#af9413be657df06123c1544d16df6b137">get_mesh</a> () const</td></tr>
<tr class="memdesc:af9413be657df06123c1544d16df6b137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the mesh. <br /></td></tr>
<tr class="separator:af9413be657df06123c1544d16df6b137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e8b9bd521b54042cccd84520011fe9"><td class="memItemLeft" align="right" valign="top"><a id="a10e8b9bd521b54042cccd84520011fe9"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a10e8b9bd521b54042cccd84520011fe9">CellDegree</a> () const</td></tr>
<tr class="memdesc:a10e8b9bd521b54042cccd84520011fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the degree of cell polynomials. <br /></td></tr>
<tr class="separator:a10e8b9bd521b54042cccd84520011fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddad16b636a2322ba97829304ce8781"><td class="memItemLeft" align="right" valign="top"><a id="a3ddad16b636a2322ba97829304ce8781"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>CellDegreePos</b> () const</td></tr>
<tr class="separator:a3ddad16b636a2322ba97829304ce8781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd72ee1721337185ed3c39da286e2928"><td class="memItemLeft" align="right" valign="top"><a id="abd72ee1721337185ed3c39da286e2928"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#abd72ee1721337185ed3c39da286e2928">FaceDegree</a> () const</td></tr>
<tr class="memdesc:abd72ee1721337185ed3c39da286e2928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the degree of face polynomials. <br /></td></tr>
<tr class="separator:abd72ee1721337185ed3c39da286e2928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3d4f37c8aef9a9b74f015bd2da41ea"><td class="memItemLeft" align="right" valign="top"><a id="afb3d4f37c8aef9a9b74f015bd2da41ea"></a>
const <a class="el" href="classHArDCore3D_1_1HybridCore.html#a5c478c9953257f154d2ea98f115fba0d">PolyCellBasisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#afb3d4f37c8aef9a9b74f015bd2da41ea">CellBasis</a> (size_t iT) const</td></tr>
<tr class="memdesc:afb3d4f37c8aef9a9b74f015bd2da41ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return cell basis for element with global index iT. <br /></td></tr>
<tr class="separator:afb3d4f37c8aef9a9b74f015bd2da41ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db5bc8811abd5cb2a264486f61c0ad2"><td class="memItemLeft" align="right" valign="top"><a id="a5db5bc8811abd5cb2a264486f61c0ad2"></a>
const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ab02b7a4490b6a739e2d084e9a70dbcc5">PolyFaceBasisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a5db5bc8811abd5cb2a264486f61c0ad2">FaceBasis</a> (size_t iF) const</td></tr>
<tr class="memdesc:a5db5bc8811abd5cb2a264486f61c0ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return face basis for face with global index iF. <br /></td></tr>
<tr class="separator:a5db5bc8811abd5cb2a264486f61c0ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21071e365011fbb477a70475f7642f02"><td class="memItemLeft" align="right" valign="top"><a id="a21071e365011fbb477a70475f7642f02"></a>
const <a class="el" href="classHArDCore3D_1_1HybridCore.html#ad3123dceabd79eec7cdb57ba1014fc17">PolyEdgeBasisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a21071e365011fbb477a70475f7642f02">EdgeBasis</a> (size_t iE) const</td></tr>
<tr class="memdesc:a21071e365011fbb477a70475f7642f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return edge basis for edge with global index iE. <br /></td></tr>
<tr class="separator:a21071e365011fbb477a70475f7642f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37ab89bf946e237821dd978f475b7c8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#ab37ab89bf946e237821dd978f475b7c8">L2norm</a> (const <a class="el" href="classHArDCore3D_1_1UVector.html">UVector</a> &amp;Xh) const</td></tr>
<tr class="memdesc:ab37ab89bf946e237821dd978f475b7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L2 norm of a discrete function (using cell values)  <a href="#ab37ab89bf946e237821dd978f475b7c8">More...</a><br /></td></tr>
<tr class="separator:ab37ab89bf946e237821dd978f475b7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6672e0691764ec5752eb1a9a7257792"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#ad6672e0691764ec5752eb1a9a7257792">H1norm</a> (const <a class="el" href="classHArDCore3D_1_1UVector.html">UVector</a> &amp;Xh) const</td></tr>
<tr class="memdesc:ad6672e0691764ec5752eb1a9a7257792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute discrete H1 norm of a discrete function.  <a href="#ad6672e0691764ec5752eb1a9a7257792">More...</a><br /></td></tr>
<tr class="separator:ad6672e0691764ec5752eb1a9a7257792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce852531f9197a35e11e1bf9995e827"><td class="memTemplParams" colspan="2">template&lt;typename ContinuousFunction &gt; </td></tr>
<tr class="memitem:gadce852531f9197a35e11e1bf9995e827"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classHArDCore3D_1_1UVector.html">UVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gadce852531f9197a35e11e1bf9995e827">interpolate</a> (const ContinuousFunction &amp;f, const int deg_cell, const size_t deg_face, size_t doe) const</td></tr>
<tr class="memdesc:gadce852531f9197a35e11e1bf9995e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolant in the discrete space of a continuous function.  <a href="group__HybridCore.html#gadce852531f9197a35e11e1bf9995e827">More...</a><br /></td></tr>
<tr class="separator:gadce852531f9197a35e11e1bf9995e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06825c5d156026d465a2798389aa952b"><td class="memItemLeft" align="right" valign="top"><a id="a06825c5d156026d465a2798389aa952b"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a06825c5d156026d465a2798389aa952b">compute_weights</a> (size_t iT) const</td></tr>
<tr class="memdesc:a06825c5d156026d465a2798389aa952b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weights to get cell values from face values when l=-1. <br /></td></tr>
<tr class="separator:a06825c5d156026d465a2798389aa952b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c76abf42a1d56fbf863d8258690497c"><td class="memItemLeft" align="right" valign="top"><a id="a9c76abf42a1d56fbf863d8258690497c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a9c76abf42a1d56fbf863d8258690497c">evaluate_in_cell</a> (const <a class="el" href="classHArDCore3D_1_1UVector.html">UVector</a> Xh, size_t iT, VectorRd x) const</td></tr>
<tr class="memdesc:a9c76abf42a1d56fbf863d8258690497c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function in the cell iT at point x. <br /></td></tr>
<tr class="separator:a9c76abf42a1d56fbf863d8258690497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088adb7dbbde4b63229b404ee72ed9ea"><td class="memItemLeft" align="right" valign="top"><a id="a088adb7dbbde4b63229b404ee72ed9ea"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a088adb7dbbde4b63229b404ee72ed9ea">evaluate_in_face</a> (const <a class="el" href="classHArDCore3D_1_1UVector.html">UVector</a> Xh, size_t iF, VectorRd x) const</td></tr>
<tr class="memdesc:a088adb7dbbde4b63229b404ee72ed9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function on the face iF at point x. <br /></td></tr>
<tr class="separator:a088adb7dbbde4b63229b404ee72ed9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d33ec0786b8127a161384ecf8f04018"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1HybridCore.html#a1d33ec0786b8127a161384ecf8f04018">VertexValues</a> (const <a class="el" href="classHArDCore3D_1_1UVector.html">UVector</a> Xh, const std::string from_dofs)</td></tr>
<tr class="memdesc:a1d33ec0786b8127a161384ecf8f04018"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a hybrid function, computes a vector of values at the vertices of the mesh.  <a href="#a1d33ec0786b8127a161384ecf8f04018">More...</a><br /></td></tr>
<tr class="separator:a1d33ec0786b8127a161384ecf8f04018"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a> class provides an interface for generating polynomial basis functions on cell, faces and edges, interpolation of continuous functions, discrete norms of vectors of coefficients, and methods to evaluate discrete functions (given by vectors of coefficients) in the cells, on the faces, or at vertices (averaged of cell or face values)</p>
<p>The current implementation has the following behaviours/expectations:</p><ul>
<li><a class="el" href="classHArDCore3D_1_1Face.html" title="The Face class provides description of an edge. ">Face</a> polynomials must be at least of degree 0, and face basis functions are always generated</li>
<li><a class="el" href="classHArDCore3D_1_1Cell.html" title="The Cell class provides description of a cell. ">Cell</a> polynomials could be of degree -1, or 0+. In the former case, basis functions of degree 0 are generated, but a function is provided to compute weights to express the cell values in terms of linearly exact averages of face values. This function is used, e.g., when interpolating a continuous function.</li>
<li><a class="el" href="classHArDCore3D_1_1Edge.html" title="The Edge class provides description of an edge. ">Edge</a> polynomials could be of degree 0+, or -1 in which case the edge basis functions are not generated </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af74bfd2755cae90735669032bec84918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74bfd2755cae90735669032bec84918">&#9670;&nbsp;</a></span>HybridCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HybridCore::HybridCore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore3D_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cell_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>face_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>edge_deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_threads</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions. </p>
<p>The orthonormalisation comes at a cost in terms of manipulation of the basis functions. This should only be used when the polynomial degree is large and/or the cell is distorted. However, in these cases, it can make a huge difference on the observed convergence rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_ptr</td><td>A pointer to the loaded mesh </td></tr>
    <tr><td class="paramname">cell_deg</td><td>The degree of the cell polynomials </td></tr>
    <tr><td class="paramname">face_deg</td><td>The degree of the face polynomials </td></tr>
    <tr><td class="paramname">edge_deg</td><td>The degree of the edge polynomials </td></tr>
    <tr><td class="paramname">use_threads</td><td>Optional argument to indicate if threads should be used </td></tr>
    <tr><td class="paramname">output</td><td>Optional argument for specifying outputs of messages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad6672e0691764ec5752eb1a9a7257792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6672e0691764ec5752eb1a9a7257792">&#9670;&nbsp;</a></span>H1norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HybridCore::H1norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore3D_1_1UVector.html">UVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Xh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute discrete H1 norm of a discrete function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Xh</td><td>Vector of unknowns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab37ab89bf946e237821dd978f475b7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37ab89bf946e237821dd978f475b7c8">&#9670;&nbsp;</a></span>L2norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HybridCore::L2norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore3D_1_1UVector.html">UVector</a> &amp;&#160;</td>
          <td class="paramname"><em>Xh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute L2 norm of a discrete function (using cell values) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Xh</td><td>Vector of unknowns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d33ec0786b8127a161384ecf8f04018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d33ec0786b8127a161384ecf8f04018">&#9670;&nbsp;</a></span>VertexValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HybridCore::VertexValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore3D_1_1UVector.html">UVector</a>&#160;</td>
          <td class="paramname"><em>Xh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>from_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From a hybrid function, computes a vector of values at the vertices of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Xh</td><td>vector of discrete unknowns on cell and face polynomials </td></tr>
    <tr><td class="paramname">from_dofs</td><td>Type of unknowns to use: "cell" or "face" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/HybridCore/<a class="el" href="hybridcore_8hpp_source.html">hybridcore.hpp</a></li>
<li>src/HybridCore/hybridcore.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
