\hypertarget{classHArDCore3D_1_1HybridCore}{}\section{H\+Ar\+D\+Core3D\+:\+:Hybrid\+Core Class Reference}
\label{classHArDCore3D_1_1HybridCore}\index{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core@{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core}}


{\ttfamily \#include $<$hybridcore.\+hpp$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_a5c478c9953257f154d2ea98f115fba0d}\label{classHArDCore3D_1_1HybridCore_a5c478c9953257f154d2ea98f115fba0d}} 
typedef \hyperlink{classHArDCore3D_1_1Family}{Family}$<$ \hyperlink{classHArDCore3D_1_1MonomialScalarBasisCell}{Monomial\+Scalar\+Basis\+Cell} $>$ \hyperlink{classHArDCore3D_1_1HybridCore_a5c478c9953257f154d2ea98f115fba0d}{Poly\+Cell\+Basis\+Type}
\begin{DoxyCompactList}\small\item\em type for cell basis \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_ab02b7a4490b6a739e2d084e9a70dbcc5}\label{classHArDCore3D_1_1HybridCore_ab02b7a4490b6a739e2d084e9a70dbcc5}} 
typedef \hyperlink{classHArDCore3D_1_1Family}{Family}$<$ \hyperlink{classHArDCore3D_1_1MonomialScalarBasisFace}{Monomial\+Scalar\+Basis\+Face} $>$ \hyperlink{classHArDCore3D_1_1HybridCore_ab02b7a4490b6a739e2d084e9a70dbcc5}{Poly\+Face\+Basis\+Type}
\begin{DoxyCompactList}\small\item\em type for face basis \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_ad3123dceabd79eec7cdb57ba1014fc17}\label{classHArDCore3D_1_1HybridCore_ad3123dceabd79eec7cdb57ba1014fc17}} 
typedef \hyperlink{classHArDCore3D_1_1Family}{Family}$<$ \hyperlink{classHArDCore3D_1_1MonomialScalarBasisEdge}{Monomial\+Scalar\+Basis\+Edge} $>$ \hyperlink{classHArDCore3D_1_1HybridCore_ad3123dceabd79eec7cdb57ba1014fc17}{Poly\+Edge\+Basis\+Type}
\begin{DoxyCompactList}\small\item\em type for edge basis \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classHArDCore3D_1_1HybridCore_af74bfd2755cae90735669032bec84918}{Hybrid\+Core} (const \hyperlink{classHArDCore3D_1_1Mesh}{Mesh} $\ast$mesh\+\_\+ptr, const int cell\+\_\+deg, const size\+\_\+t face\+\_\+deg, const int edge\+\_\+deg, const bool use\+\_\+threads=true, std\+::ostream \&output=std\+::cout)
\begin{DoxyCompactList}\small\item\em Class constructor\+: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_af9413be657df06123c1544d16df6b137}\label{classHArDCore3D_1_1HybridCore_af9413be657df06123c1544d16df6b137}} 
const \hyperlink{classHArDCore3D_1_1Mesh}{Mesh} $\ast$ \hyperlink{classHArDCore3D_1_1HybridCore_af9413be657df06123c1544d16df6b137}{get\+\_\+mesh} () const
\begin{DoxyCompactList}\small\item\em Returns a pointer to the mesh. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_a10e8b9bd521b54042cccd84520011fe9}\label{classHArDCore3D_1_1HybridCore_a10e8b9bd521b54042cccd84520011fe9}} 
const int \hyperlink{classHArDCore3D_1_1HybridCore_a10e8b9bd521b54042cccd84520011fe9}{Cell\+Degree} () const
\begin{DoxyCompactList}\small\item\em Return the degree of cell polynomials. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_a3ddad16b636a2322ba97829304ce8781}\label{classHArDCore3D_1_1HybridCore_a3ddad16b636a2322ba97829304ce8781}} 
const int {\bfseries Cell\+Degree\+Pos} () const
\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_abd72ee1721337185ed3c39da286e2928}\label{classHArDCore3D_1_1HybridCore_abd72ee1721337185ed3c39da286e2928}} 
const size\+\_\+t \hyperlink{classHArDCore3D_1_1HybridCore_abd72ee1721337185ed3c39da286e2928}{Face\+Degree} () const
\begin{DoxyCompactList}\small\item\em Return the degree of face polynomials. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_afb3d4f37c8aef9a9b74f015bd2da41ea}\label{classHArDCore3D_1_1HybridCore_afb3d4f37c8aef9a9b74f015bd2da41ea}} 
const \hyperlink{classHArDCore3D_1_1HybridCore_a5c478c9953257f154d2ea98f115fba0d}{Poly\+Cell\+Basis\+Type} \& \hyperlink{classHArDCore3D_1_1HybridCore_afb3d4f37c8aef9a9b74f015bd2da41ea}{Cell\+Basis} (size\+\_\+t iT) const
\begin{DoxyCompactList}\small\item\em Return cell basis for element with global index iT. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_a5db5bc8811abd5cb2a264486f61c0ad2}\label{classHArDCore3D_1_1HybridCore_a5db5bc8811abd5cb2a264486f61c0ad2}} 
const \hyperlink{classHArDCore3D_1_1HybridCore_ab02b7a4490b6a739e2d084e9a70dbcc5}{Poly\+Face\+Basis\+Type} \& \hyperlink{classHArDCore3D_1_1HybridCore_a5db5bc8811abd5cb2a264486f61c0ad2}{Face\+Basis} (size\+\_\+t iF) const
\begin{DoxyCompactList}\small\item\em Return face basis for face with global index iF. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_a21071e365011fbb477a70475f7642f02}\label{classHArDCore3D_1_1HybridCore_a21071e365011fbb477a70475f7642f02}} 
const \hyperlink{classHArDCore3D_1_1HybridCore_ad3123dceabd79eec7cdb57ba1014fc17}{Poly\+Edge\+Basis\+Type} \& \hyperlink{classHArDCore3D_1_1HybridCore_a21071e365011fbb477a70475f7642f02}{Edge\+Basis} (size\+\_\+t iE) const
\begin{DoxyCompactList}\small\item\em Return edge basis for edge with global index iE. \end{DoxyCompactList}\item 
double \hyperlink{classHArDCore3D_1_1HybridCore_ab37ab89bf946e237821dd978f475b7c8}{L2norm} (const \hyperlink{classHArDCore3D_1_1UVector}{U\+Vector} \&Xh) const
\begin{DoxyCompactList}\small\item\em Compute L2 norm of a discrete function (using cell values) \end{DoxyCompactList}\item 
double \hyperlink{classHArDCore3D_1_1HybridCore_ad6672e0691764ec5752eb1a9a7257792}{H1norm} (const \hyperlink{classHArDCore3D_1_1UVector}{U\+Vector} \&Xh) const
\begin{DoxyCompactList}\small\item\em Compute discrete H1 norm of a discrete function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Continuous\+Function $>$ }\\\hyperlink{classHArDCore3D_1_1UVector}{U\+Vector} \hyperlink{group__HybridCore_gadce852531f9197a35e11e1bf9995e827}{interpolate} (const Continuous\+Function \&f, const int deg\+\_\+cell, const size\+\_\+t deg\+\_\+face, size\+\_\+t doe) const
\begin{DoxyCompactList}\small\item\em Compute the interpolant in the discrete space of a continuous function. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_a06825c5d156026d465a2798389aa952b}\label{classHArDCore3D_1_1HybridCore_a06825c5d156026d465a2798389aa952b}} 
Eigen\+::\+Vector\+Xd \hyperlink{classHArDCore3D_1_1HybridCore_a06825c5d156026d465a2798389aa952b}{compute\+\_\+weights} (size\+\_\+t iT) const
\begin{DoxyCompactList}\small\item\em Computes the weights to get cell values from face values when l=-\/1. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_a9c76abf42a1d56fbf863d8258690497c}\label{classHArDCore3D_1_1HybridCore_a9c76abf42a1d56fbf863d8258690497c}} 
double \hyperlink{classHArDCore3D_1_1HybridCore_a9c76abf42a1d56fbf863d8258690497c}{evaluate\+\_\+in\+\_\+cell} (const \hyperlink{classHArDCore3D_1_1UVector}{U\+Vector} Xh, size\+\_\+t iT, Vector\+Rd x) const
\begin{DoxyCompactList}\small\item\em Evaluates a discrete function in the cell iT at point x. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_a088adb7dbbde4b63229b404ee72ed9ea}\label{classHArDCore3D_1_1HybridCore_a088adb7dbbde4b63229b404ee72ed9ea}} 
double \hyperlink{classHArDCore3D_1_1HybridCore_a088adb7dbbde4b63229b404ee72ed9ea}{evaluate\+\_\+in\+\_\+face} (const \hyperlink{classHArDCore3D_1_1UVector}{U\+Vector} Xh, size\+\_\+t iF, Vector\+Rd x) const
\begin{DoxyCompactList}\small\item\em Evaluates a discrete function on the face iF at point x. \end{DoxyCompactList}\item 
Eigen\+::\+Vector\+Xd \hyperlink{classHArDCore3D_1_1HybridCore_a1d33ec0786b8127a161384ecf8f04018}{Vertex\+Values} (const \hyperlink{classHArDCore3D_1_1UVector}{U\+Vector} Xh, const std\+::string from\+\_\+dofs)
\begin{DoxyCompactList}\small\item\em From a hybrid function, computes a vector of values at the vertices of the mesh. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The \hyperlink{classHArDCore3D_1_1HybridCore}{Hybrid\+Core} class provides an interface for generating polynomial basis functions on cell, faces and edges, interpolation of continuous functions, discrete norms of vectors of coefficients, and methods to evaluate discrete functions (given by vectors of coefficients) in the cells, on the faces, or at vertices (averaged of cell or face values)

The current implementation has the following behaviours/expectations\+:
\begin{DoxyItemize}
\item \hyperlink{classHArDCore3D_1_1Face}{Face} polynomials must be at least of degree 0, and face basis functions are always generated
\item \hyperlink{classHArDCore3D_1_1Cell}{Cell} polynomials could be of degree -\/1, or 0+. In the former case, basis functions of degree 0 are generated, but a function is provided to compute weights to express the cell values in terms of linearly exact averages of face values. This function is used, e.\+g., when interpolating a continuous function.
\item \hyperlink{classHArDCore3D_1_1Edge}{Edge} polynomials could be of degree 0+, or -\/1 in which case the edge basis functions are not generated 
\end{DoxyItemize}

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_af74bfd2755cae90735669032bec84918}\label{classHArDCore3D_1_1HybridCore_af74bfd2755cae90735669032bec84918}} 
\index{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core@{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core}!Hybrid\+Core@{Hybrid\+Core}}
\index{Hybrid\+Core@{Hybrid\+Core}!H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core@{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core}}
\subsubsection{\texorpdfstring{Hybrid\+Core()}{HybridCore()}}
{\footnotesize\ttfamily Hybrid\+Core\+::\+Hybrid\+Core (\begin{DoxyParamCaption}\item[{const \hyperlink{classHArDCore3D_1_1Mesh}{Mesh} $\ast$}]{mesh\+\_\+ptr,  }\item[{const int}]{cell\+\_\+deg,  }\item[{const size\+\_\+t}]{face\+\_\+deg,  }\item[{const int}]{edge\+\_\+deg,  }\item[{const bool}]{use\+\_\+threads = {\ttfamily true},  }\item[{std\+::ostream \&}]{output = {\ttfamily std\+:\+:cout} }\end{DoxyParamCaption})}



Class constructor\+: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions. 

The orthonormalisation comes at a cost in terms of manipulation of the basis functions. This should only be used when the polynomial degree is large and/or the cell is distorted. However, in these cases, it can make a huge difference on the observed convergence rate. 
\begin{DoxyParams}{Parameters}
{\em mesh\+\_\+ptr} & A pointer to the loaded mesh \\
\hline
{\em cell\+\_\+deg} & The degree of the cell polynomials \\
\hline
{\em face\+\_\+deg} & The degree of the face polynomials \\
\hline
{\em edge\+\_\+deg} & The degree of the edge polynomials \\
\hline
{\em use\+\_\+threads} & Optional argument to indicate if threads should be used \\
\hline
{\em output} & Optional argument for specifying outputs of messages. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_ad6672e0691764ec5752eb1a9a7257792}\label{classHArDCore3D_1_1HybridCore_ad6672e0691764ec5752eb1a9a7257792}} 
\index{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core@{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core}!H1norm@{H1norm}}
\index{H1norm@{H1norm}!H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core@{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core}}
\subsubsection{\texorpdfstring{H1norm()}{H1norm()}}
{\footnotesize\ttfamily double Hybrid\+Core\+::\+H1norm (\begin{DoxyParamCaption}\item[{const \hyperlink{classHArDCore3D_1_1UVector}{U\+Vector} \&}]{Xh }\end{DoxyParamCaption}) const}



Compute discrete H1 norm of a discrete function. 


\begin{DoxyParams}{Parameters}
{\em Xh} & Vector of unknowns \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_ab37ab89bf946e237821dd978f475b7c8}\label{classHArDCore3D_1_1HybridCore_ab37ab89bf946e237821dd978f475b7c8}} 
\index{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core@{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core}!L2norm@{L2norm}}
\index{L2norm@{L2norm}!H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core@{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core}}
\subsubsection{\texorpdfstring{L2norm()}{L2norm()}}
{\footnotesize\ttfamily double Hybrid\+Core\+::\+L2norm (\begin{DoxyParamCaption}\item[{const \hyperlink{classHArDCore3D_1_1UVector}{U\+Vector} \&}]{Xh }\end{DoxyParamCaption}) const}



Compute L2 norm of a discrete function (using cell values) 


\begin{DoxyParams}{Parameters}
{\em Xh} & Vector of unknowns \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classHArDCore3D_1_1HybridCore_a1d33ec0786b8127a161384ecf8f04018}\label{classHArDCore3D_1_1HybridCore_a1d33ec0786b8127a161384ecf8f04018}} 
\index{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core@{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core}!Vertex\+Values@{Vertex\+Values}}
\index{Vertex\+Values@{Vertex\+Values}!H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core@{H\+Ar\+D\+Core3\+D\+::\+Hybrid\+Core}}
\subsubsection{\texorpdfstring{Vertex\+Values()}{VertexValues()}}
{\footnotesize\ttfamily Eigen\+::\+Vector\+Xd Hybrid\+Core\+::\+Vertex\+Values (\begin{DoxyParamCaption}\item[{const \hyperlink{classHArDCore3D_1_1UVector}{U\+Vector}}]{Xh,  }\item[{const std\+::string}]{from\+\_\+dofs }\end{DoxyParamCaption})}



From a hybrid function, computes a vector of values at the vertices of the mesh. 


\begin{DoxyParams}{Parameters}
{\em Xh} & vector of discrete unknowns on cell and face polynomials \\
\hline
{\em from\+\_\+dofs} & Type of unknowns to use\+: \char`\"{}cell\char`\"{} or \char`\"{}face\char`\"{} \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\+Hybrid\+Core/hybridcore.\+hpp\item 
src/\+Hybrid\+Core/hybridcore.\+cpp\end{DoxyCompactItemize}
