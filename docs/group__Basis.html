<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core3D: Basis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core3D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 3D - Library to implement 3D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Basis</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes and functions for polynomial basis creation and manipulation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1MonomialScalarBasisCell.html">HArDCore3D::MonomialScalarBasisCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar monomial basis on a cell.  <a href="classHArDCore3D_1_1MonomialScalarBasisCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1MonomialScalarBasisFace.html">HArDCore3D::MonomialScalarBasisFace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar monomial basis on a face.  <a href="classHArDCore3D_1_1MonomialScalarBasisFace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1MonomialScalarBasisEdge.html">HArDCore3D::MonomialScalarBasisEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar monomial basis on an edge.  <a href="classHArDCore3D_1_1MonomialScalarBasisEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1Family.html">HArDCore3D::Family&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1TensorizedVectorFamily.html">HArDCore3D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1TangentFamily.html">HArDCore3D::TangentFamily&lt; ScalarFamilyType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector family for tangent functions.  <a href="classHArDCore3D_1_1TangentFamily.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1ShiftedBasis.html">HArDCore3D::ShiftedBasis&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1RestrictedBasis.html">HArDCore3D::RestrictedBasis&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1GradientBasis.html">HArDCore3D::GradientBasis&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore3D_1_1CurlBasis.html">HArDCore3D::CurlBasis&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore3D_1_1evaluate__quad.html">HArDCore3D::evaluate_quad&lt; BasisFunction &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafa49064b5221a119dd0271fb5f8ddbb1"><td class="memItemLeft" align="right" valign="top"><a id="gafa49064b5221a119dd0271fb5f8ddbb1"></a>
typedef Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore3D::VectorRd</b></td></tr>
<tr class="separator:gafa49064b5221a119dd0271fb5f8ddbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeaa2d1c651a6a71697e40f9e8c9065b"><td class="memItemLeft" align="right" valign="top"><a id="gadeaa2d1c651a6a71697e40f9e8c9065b"></a>
typedef Eigen::Vector3i&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore3D::VectorZd</b></td></tr>
<tr class="separator:gadeaa2d1c651a6a71697e40f9e8c9065b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga81eb4732214b7560fbfa4ee9495c6da4"><td class="memItemLeft" align="right" valign="top"><a id="ga81eb4732214b7560fbfa4ee9495c6da4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TensorRankE</b> { <b>Scalar</b> = 0, 
<b>Vector</b> = 1, 
<b>Matrix</b> = 2
 }</td></tr>
<tr class="separator:ga81eb4732214b7560fbfa4ee9495c6da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be971bd231f83ec8d9cfd644a374180"><td class="memItemLeft" align="right" valign="top"><a id="ga7be971bd231f83ec8d9cfd644a374180"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BasisFunctionE</b> { <b>Function</b>, 
<b>Gradient</b>, 
<b>Curl</b>, 
<b>Divergence</b>
 }</td></tr>
<tr class="separator:ga7be971bd231f83ec8d9cfd644a374180"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5452c71e3652aa957d105446a95826e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5452c71e3652aa957d105446a95826e8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga5452c71e3652aa957d105446a95826e8">HArDCore3D::gram_schmidt</a> (boost::multi_array&lt; T, 2 &gt; &amp;basis_eval, const std::function&lt; double(size_t, size_t)&gt; &amp;inner_product)</td></tr>
<tr class="separator:ga5452c71e3652aa957d105446a95826e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a7162dd1acacd29421a7d8db89c96e"><td class="memItemLeft" align="right" valign="top"><a id="ga46a7162dd1acacd29421a7d8db89c96e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga46a7162dd1acacd29421a7d8db89c96e">HArDCore3D::scalar_product</a> (const double &amp;x, const double &amp;y)</td></tr>
<tr class="memdesc:ga46a7162dd1acacd29421a7d8db89c96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product between two reals. <br /></td></tr>
<tr class="separator:ga46a7162dd1acacd29421a7d8db89c96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0105ef2d1903eeddce62e6ad647a8ead"><td class="memItemLeft" align="right" valign="top"><a id="ga0105ef2d1903eeddce62e6ad647a8ead"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga0105ef2d1903eeddce62e6ad647a8ead">HArDCore3D::scalar_product</a> (const VectorRd &amp;x, const VectorRd &amp;y)</td></tr>
<tr class="memdesc:ga0105ef2d1903eeddce62e6ad647a8ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product between two vectors. <br /></td></tr>
<tr class="separator:ga0105ef2d1903eeddce62e6ad647a8ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeaa152dde6743b3293a88f14d907e7c"><td class="memItemLeft" align="right" valign="top">boost::multi_array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaeeaa152dde6743b3293a88f14d907e7c">HArDCore3D::scalar_product</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;basis_quad, const VectorRd &amp;v)</td></tr>
<tr class="separator:gaeeaa152dde6743b3293a88f14d907e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd6906b30cba10f2f452b029a86ca00"><td class="memItemLeft" align="right" valign="top">boost::multi_array&lt; VectorRd, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga7fd6906b30cba10f2f452b029a86ca00">HArDCore3D::vector_product</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;basis_quad, const VectorRd &amp;v)</td></tr>
<tr class="memdesc:ga7fd6906b30cba10f2f452b029a86ca00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vector product between the evaluation of a basis and a constant vector.  <a href="group__Basis.html#ga7fd6906b30cba10f2f452b029a86ca00">More...</a><br /></td></tr>
<tr class="separator:ga7fd6906b30cba10f2f452b029a86ca00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087cb67abbfba7c2d90f67a4e05abc20"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga087cb67abbfba7c2d90f67a4e05abc20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classHArDCore3D_1_1Family.html">Family</a>&lt; BasisType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga087cb67abbfba7c2d90f67a4e05abc20">HArDCore3D::l2_orthonormalize</a> (const BasisType &amp;basis, const QuadratureRule &amp;qr, boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;basis_quad)</td></tr>
<tr class="memdesc:ga087cb67abbfba7c2d90f67a4e05abc20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><img class="formulaInl" alt="$L^2$" src="form_38.png"/>-orthonormalization: simply consists in using <a class="el" href="group__Basis.html#ga5452c71e3652aa957d105446a95826e8">gram_schmidt()</a> with the specific l2 inner product  <a href="group__Basis.html#ga087cb67abbfba7c2d90f67a4e05abc20">More...</a><br /></td></tr>
<tr class="separator:ga087cb67abbfba7c2d90f67a4e05abc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224969a8de049faa61bc39d3975bb237"><td class="memTemplParams" colspan="2">template&lt;typename FunctionValue &gt; </td></tr>
<tr class="memitem:ga224969a8de049faa61bc39d3975bb237"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga224969a8de049faa61bc39d3975bb237">HArDCore3D::compute_gram_matrix</a> (const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B1, const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const size_t nrows, const size_t ncols, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="separator:ga224969a8de049faa61bc39d3975bb237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9385a57c81b496ebabea12f8d3c2f068"><td class="memTemplParams" colspan="2">template&lt;typename FunctionValue &gt; </td></tr>
<tr class="memitem:ga9385a57c81b496ebabea12f8d3c2f068"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga9385a57c81b496ebabea12f8d3c2f068">HArDCore3D::compute_gram_matrix</a> (const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B1, const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="separator:ga9385a57c81b496ebabea12f8d3c2f068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacecea1b90076ee784d7950da4d31749f"><td class="memTemplParams" colspan="2">template&lt;typename FunctionValue &gt; </td></tr>
<tr class="memitem:gacecea1b90076ee784d7950da4d31749f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#gacecea1b90076ee784d7950da4d31749f">HArDCore3D::compute_gram_matrix</a> (const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B, const QuadratureRule &amp;qr)</td></tr>
<tr class="separator:gacecea1b90076ee784d7950da4d31749f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5cc3ed71949b5d7adc5877e6bfebcb4"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaf5cc3ed71949b5d7adc5877e6bfebcb4">HArDCore3D::compute_gram_matrix</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr)</td></tr>
<tr class="separator:gaf5cc3ed71949b5d7adc5877e6bfebcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac574f3b532690c1d59b2bfc48023ab3b"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gac574f3b532690c1d59b2bfc48023ab3b">HArDCore3D::compute_gram_matrix</a> (const boost::multi_array&lt; double, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const size_t nrows, const size_t ncols, const std::string sym)</td></tr>
<tr class="separator:gac574f3b532690c1d59b2bfc48023ab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf151d3a8c29e1b18fd67b89eae756eca"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaf151d3a8c29e1b18fd67b89eae756eca">HArDCore3D::compute_gram_matrix</a> (const boost::multi_array&lt; double, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym)</td></tr>
<tr class="separator:gaf151d3a8c29e1b18fd67b89eae756eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b9c4c2ff96b783e8096d584a3e80a9"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga33b9c4c2ff96b783e8096d584a3e80a9">HArDCore3D::compute_gram_matrix</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const size_t nrows, const size_t ncols, const std::string sym)</td></tr>
<tr class="separator:ga33b9c4c2ff96b783e8096d584a3e80a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a3cd2df90246841fb82bfff01665ba"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga70a3cd2df90246841fb82bfff01665ba">HArDCore3D::compute_gram_matrix</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym)</td></tr>
<tr class="separator:ga70a3cd2df90246841fb82bfff01665ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga714906e1afa0a6d8475d177b554a7cc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga714906e1afa0a6d8475d177b554a7cc0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga714906e1afa0a6d8475d177b554a7cc0">HArDCore3D::integrate</a> (const std::function&lt; T(const VectorRd &amp;)&gt; &amp;f, const boost::multi_array&lt; T, 2 &gt; &amp;B, const QuadratureRule &amp;qr)</td></tr>
<tr class="memdesc:ga714906e1afa0a6d8475d177b554a7cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of a given function against all functions from a family.  <a href="group__Basis.html#ga714906e1afa0a6d8475d177b554a7cc0">More...</a><br /></td></tr>
<tr class="separator:ga714906e1afa0a6d8475d177b554a7cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc99a6fc8eaea7b200fc643de492bea"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga9fc99a6fc8eaea7b200fc643de492bea"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga9fc99a6fc8eaea7b200fc643de492bea">HArDCore3D::l2_projection</a> (const std::function&lt; typename BasisType::FunctionValue(const VectorRd &amp;)&gt; &amp;f, const BasisType &amp;basis, QuadratureRule &amp;quad, const boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;basis_quad)</td></tr>
<tr class="memdesc:ga9fc99a6fc8eaea7b200fc643de492bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L2-projection of a function.  <a href="group__Basis.html#ga9fc99a6fc8eaea7b200fc643de492bea">More...</a><br /></td></tr>
<tr class="separator:ga9fc99a6fc8eaea7b200fc643de492bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga23a211ab9d745e2e803ad606e1df445f"><td class="memItemLeft" align="right" valign="top"><a id="ga23a211ab9d745e2e803ad606e1df445f"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga23a211ab9d745e2e803ad606e1df445f">HArDCore3D::dimspace</a> = 3</td></tr>
<tr class="memdesc:ga23a211ab9d745e2e803ad606e1df445f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension, and generic types for vector in correct dimension (makes it easier to translate a code between 2D and 3D) <br /></td></tr>
<tr class="separator:ga23a211ab9d745e2e803ad606e1df445f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes and functions for polynomial basis creation and manipulation. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf5cc3ed71949b5d7adc5877e6bfebcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5cc3ed71949b5d7adc5877e6bfebcb4">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore3D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given a family of vector-valued and one of scalar-valued functions by tensorizing the latter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family (to be tensorized) at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac574f3b532690c1d59b2bfc48023ab3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac574f3b532690c1d59b2bfc48023ab3b">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore3D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version is an overload for double-valued families, more efficient than the generic templated version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix (nb of members of first family to consider) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of rows of the matrix (nn of members of second family to consider) </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf151d3a8c29e1b18fd67b89eae756eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf151d3a8c29e1b18fd67b89eae756eca">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore3D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. Consists in calling the double-valued version with nrows = nb of elements in B1, ncols = nb of elements in B2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33b9c4c2ff96b783e8096d584a3e80a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33b9c4c2ff96b783e8096d584a3e80a9">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore3D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version is an overload for Vector3d-valued families, more efficient than the generic templated version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">nrows</td><td>Optional. Number of rows of the matrix (nb of members of first family to consider). </td></tr>
    <tr><td class="paramname">ncols</td><td>Optional. Number of rows of the matrix (nb of members of second family to consider). </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70a3cd2df90246841fb82bfff01665ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70a3cd2df90246841fb82bfff01665ba">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore3D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. Consists in calling the Vector3d-valued version with nrows = nb of elements in B1, ncols = nb of elements in B2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga224969a8de049faa61bc39d3975bb237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga224969a8de049faa61bc39d3975bb237">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore3D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This templated function is very generic, and thus not the most efficient. More efficient overloads are provided for double- or Vector3d-valued families </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix (nb of members of first family to consider) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of rows of the matrix (nn of members of second family to consider) </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9385a57c81b496ebabea12f8d3c2f068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9385a57c81b496ebabea12f8d3c2f068">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore3D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version calls the generic one with nrows = nb of elements in family B1 and ncols = nb of elements in family B2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacecea1b90076ee784d7950da4d31749f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacecea1b90076ee784d7950da4d31749f">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore3D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Gram matrix given the evaluation of one family of functions at quadrature nodes. Consists in calling the generic templated version with B1=B2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td><a class="el" href="classHArDCore3D_1_1Family.html">Family</a> at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5452c71e3652aa957d105446a95826e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5452c71e3652aa957d105446a95826e8">&#9670;&nbsp;</a></span>gram_schmidt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore3D::gram_schmidt </td>
          <td>(</td>
          <td class="paramtype">boost::multi_array&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gram-Schmidt algorithm to ortonormalize a basis. The matrix <img class="formulaInl" alt="$M$" src="form_34.png"/> returned by this function gives the coefficients in the original basis of the orthonormalised basis. If <img class="formulaInl" alt="$(f_1,...,f_r)$" src="form_35.png"/> is the original basis, the orthonormalised basis is <img class="formulaInl" alt="$(\phi_1,...,\phi_r)$" src="form_36.png"/> where <img class="formulaInl" alt="$\phi_i = \sum_j M_{ij}f_j$" src="form_37.png"/>.</p>
<p>The function also modifies the variable basis_eval so that it contains the evaluation on at quadrature nodes of the new orthonormalised basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_eval</td><td>Evaluations at quadrature nodes of the original basis. </td></tr>
    <tr><td class="paramname">inner_product</td><td>inner product (of two original basis functions) with respect to which we orthonormalise. This inner product must only depend on the basis functions through their values basis_eval. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga714906e1afa0a6d8475d177b554a7cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga714906e1afa0a6d8475d177b554a7cc0">&#9670;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HArDCore3D::integrate </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; T(const VectorRd &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the integral of a given function against all functions from a family. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classHArDCore3D_1_1Family.html">Family</a> at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga087cb67abbfba7c2d90f67a4e05abc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga087cb67abbfba7c2d90f67a4e05abc20">&#9670;&nbsp;</a></span>l2_orthonormalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore3D_1_1Family.html">Family</a>&lt;BasisType&gt; HArDCore3D::l2_orthonormalize </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><img class="formulaInl" alt="$L^2$" src="form_38.png"/>-orthonormalization: simply consists in using <a class="el" href="group__Basis.html#ga5452c71e3652aa957d105446a95826e8">gram_schmidt()</a> with the specific l2 inner product </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>basis to orthonormalise </td></tr>
    <tr><td class="paramname">qr</td><td>quadrature rule for computing the l2 inner product </td></tr>
    <tr><td class="paramname">basis_quad</td><td>values of basis functions at quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fc99a6fc8eaea7b200fc643de492bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fc99a6fc8eaea7b200fc643de492bea">&#9670;&nbsp;</a></span>l2_projection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HArDCore3D::l2_projection </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; typename BasisType::FunctionValue(const VectorRd &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the L2-projection of a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function to project </td></tr>
    <tr><td class="paramname">basis</td><td>Basis for the space on which we project </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">basis_quad</td><td>Evaluation of the basis at quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeeaa152dde6743b3293a88f14d907e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeaa152dde6743b3293a88f14d907e7c">&#9670;&nbsp;</a></span>scalar_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::multi_array&lt; double, 2 &gt; HArDCore3D::scalar_product </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorRd &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overloading of the scalar_product function computes the scalar product between an evaluation of a basis and a constant vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_quad</td><td>The basis evaluation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to take the scalar product with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fd6906b30cba10f2f452b029a86ca00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fd6906b30cba10f2f452b029a86ca00">&#9670;&nbsp;</a></span>vector_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::multi_array&lt; VectorRd, 2 &gt; HArDCore3D::vector_product </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorRd &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the vector product between the evaluation of a basis and a constant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_quad</td><td>The basis evaluation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to take the vector product with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
