<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core3D: Schemes/HHO-locvardiff/HHO_LocVarDiff.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core3D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 3D - Library to implement 3D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_60d99d4f8bf576094f0ece8cd9292bc3.html">Schemes</a></li><li class="navelem"><a class="el" href="dir_47c9014e8939c045f8da58d62cfd936a.html">HHO-locvardiff</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">HHO_LocVarDiff.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// Implementation of the HHO scheme in 3D for the diffusion equation</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//   { -div(K \grad(u)) = f,       inside Omega</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//   { K \grad(u) . nTF = g,       on GammaN</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">//   {                              u = g,           on GammaD</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// </span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//  At the moment, only pure Neumann or pure Dirichlet</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Author: Jerome Droniou (jerome.droniou@monash.edu)</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"> *  This implementation of HHO was developped following the principles described in </span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment"> * Appendix B of the book</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * The Hybrid High-Order Method for Polytopal Meshes: Design, Analysis, and Applications.</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> * D. A. Di Pietro and J. Droniou. 2019, 516p. </span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> * url: https://hal.archives-ouvertes.fr/hal-02151813.</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"> * If you use this code or part of it for a scientific publication, please cite the book</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment"> * above as a reference for the implementation.</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#ifndef _HHO_LOCVARDIFF_HPP</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#define _HHO_LOCVARDIFF_HPP</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#include &lt;boost/timer/timer.hpp&gt;</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">// Matrices and linear solvers</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="preprocessor">#include &lt;Eigen/Sparse&gt;</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">//#include &quot;Eigen/MA41.cpp&quot;</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="preprocessor">#include &lt;vertex.hpp&gt;</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="preprocessor">#include &lt;hybridcore.hpp&gt;</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#include &lt;elementquad.hpp&gt;</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceHArDCore3D.html">HArDCore3D</a> {</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="comment">// ----------------------------------------------------------------------------</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="comment">//                            Class definition</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="comment">// ----------------------------------------------------------------------------</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno"><a class="line" href="classHArDCore3D_1_1HHO__LocVarDiff.html">   61</a></span>&#160;  <span class="keyword">class </span><a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html">HHO_LocVarDiff</a> {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="comment">// Types</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <span class="keyword">public</span>:</div><div class="line"><a name="l00065"></a><span class="lineno"><a class="line" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a57cf83c67a9bcd71822a4ebdfbe0f0ce">   65</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a57cf83c67a9bcd71822a4ebdfbe0f0ce">solution_function_type</a> = std::function&lt;double(double,double,double)&gt;;     </div><div class="line"><a name="l00066"></a><span class="lineno"><a class="line" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a478a09a65f66428a614412e7d308ffcd">   66</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a478a09a65f66428a614412e7d308ffcd">source_function_type</a> = std::function&lt;double(double,double,double,Cell*)&gt;;     </div><div class="line"><a name="l00067"></a><span class="lineno"><a class="line" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a13003c1e92aab2a21e3055e2fd7104f8">   67</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a13003c1e92aab2a21e3055e2fd7104f8">grad_function_type</a> = std::function&lt;Eigen::Vector3d(double,double,double,Cell*)&gt;;      </div><div class="line"><a name="l00068"></a><span class="lineno"><a class="line" href="classHArDCore3D_1_1HHO__LocVarDiff.html#aba48f23cd9e46ab3b0d7d907e0990bd6">   68</a></span>&#160;    <span class="keyword">using</span> <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#aba48f23cd9e46ab3b0d7d907e0990bd6">tensor_function_type</a> = std::function&lt;Eigen::Matrix3d(double,double,double,Cell*)&gt;;        </div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <a class="code" href="group__HHO__LocVarDiff.html#ga498c8ed6193d76926ca3f3627ed6cf11">HHO_LocVarDiff</a>(</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;           <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#aba48f23cd9e46ab3b0d7d907e0990bd6">tensor_function_type</a> kappa,  </div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;           <span class="keywordtype">size_t</span> deg_kappa,                            </div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;           <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a478a09a65f66428a614412e7d308ffcd">source_function_type</a> source,  </div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;           <span class="keywordtype">size_t</span> BC,                                       </div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;           <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a57cf83c67a9bcd71822a4ebdfbe0f0ce">solution_function_type</a> exact_solution,   </div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;           <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a13003c1e92aab2a21e3055e2fd7104f8">grad_function_type</a> grad_exact_solution,  </div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;           std::string solver_type      </div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;           );</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    Eigen::VectorXd <a class="code" href="group__HHO__LocVarDiff.html#gab01c6aad8ad6264f67f866ec26c8055d">solve</a>(<a class="code" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a>&amp; hho);</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#gab04749bad041c0ed9e91c54f262d42e1">EnergyNorm</a>(<a class="code" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> Eigen::VectorXd Xh); </div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga4232eab7b9753215b506d5ce701c4f4f">get_assembly_time</a>() <span class="keyword">const</span>; </div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga10971b2952ab54d336127a43f5ed9b29">get_solving_time</a>() <span class="keyword">const</span>;    </div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga22542468093ee4e8e24d8c0a27946f8f">get_solving_error</a>() <span class="keyword">const</span>;   </div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#gae66d0e79903e2ca077ff2515c20d7d2e">get_itime</a>(<span class="keywordtype">size_t</span> idx) <span class="keyword">const</span>;     </div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  <span class="keyword">private</span>:</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    Eigen::MatrixXd diffusion_operator(<a class="code" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore3D_1_1ElementQuad.html">ElementQuad</a>&amp; elquad) <span class="keyword">const</span>;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    Eigen::VectorXd load_operator(<a class="code" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore3D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad) <span class="keyword">const</span>;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keyword">const</span> <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#aba48f23cd9e46ab3b0d7d907e0990bd6">tensor_function_type</a> kappa;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <span class="keywordtype">size_t</span> _deg_kappa;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keyword">const</span> <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a478a09a65f66428a614412e7d308ffcd">source_function_type</a> source;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> BC;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="keyword">const</span> <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a57cf83c67a9bcd71822a4ebdfbe0f0ce">solution_function_type</a> exact_solution;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keyword">const</span> <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a13003c1e92aab2a21e3055e2fd7104f8">grad_function_type</a> grad_exact_solution;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keyword">const</span> std::string solver_type;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="comment">// To store local bilinear forms</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    std::vector&lt;Eigen::MatrixXd&gt; aT;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="comment">// Computation statistics</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordtype">size_t</span> _assembly_time;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordtype">size_t</span> _solving_time;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keywordtype">double</span> _solving_error;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keyword">mutable</span> std::vector&lt;size_t&gt; _itime = std::vector&lt;size_t&gt;(10, 0);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  };</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga498c8ed6193d76926ca3f3627ed6cf11">  118</a></span>&#160;  <a class="code" href="group__HHO__LocVarDiff.html#ga498c8ed6193d76926ca3f3627ed6cf11">HHO_LocVarDiff::HHO_LocVarDiff</a>(<a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#aba48f23cd9e46ab3b0d7d907e0990bd6">tensor_function_type</a> kappa, <span class="keywordtype">size_t</span> deg_kappa, <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a478a09a65f66428a614412e7d308ffcd">source_function_type</a> source, <span class="keywordtype">size_t</span> BC, <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a57cf83c67a9bcd71822a4ebdfbe0f0ce">solution_function_type</a> exact_solution, <a class="code" href="classHArDCore3D_1_1HHO__LocVarDiff.html#a13003c1e92aab2a21e3055e2fd7104f8">grad_function_type</a> grad_exact_solution, std::string solver_type)</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    : kappa(kappa),</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;      _deg_kappa(deg_kappa),</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;      source(source),</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;      BC(BC),</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;      exact_solution(exact_solution),</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      grad_exact_solution(grad_exact_solution),</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      solver_type(solver_type) {</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="comment">// Do nothing</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  }</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#gab01c6aad8ad6264f67f866ec26c8055d">  129</a></span>&#160;  Eigen::VectorXd <a class="code" href="group__HHO__LocVarDiff.html#gab01c6aad8ad6264f67f866ec26c8055d">HHO_LocVarDiff::solve</a>(<a class="code" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a> &amp;hho) {</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    boost::timer::cpu_timer timer;  <span class="comment">// Time the matrix assembly</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    boost::timer::cpu_timer timerint; </div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#gad4c32f117a1e67ec4a13dd9656c404e8">get_mesh_ptr</a>();</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    aT.resize(mesh-&gt;n_cells());</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="comment">//--------------- PREPARE SYSTEM ------------------------//</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="comment">// System matrix</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    Eigen::SparseMatrix&lt;double&gt; GlobMat(hho.<a class="code" href="group__HybridCore.html#gab2e20ded434d1aacc44927934faabc1c">ntotal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab2e20ded434d1aacc44927934faabc1c">ntotal_face_dofs</a>());</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets_GlobMat;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="comment">// If static condensation (L&gt;=0): matrix to recover cell unknowns</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    <span class="comment">// If barycentric elimination (L=-1): matrix to recover cell unknowns</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    Eigen::SparseMatrix&lt;double&gt; ScBeMat(hho.<a class="code" href="group__HybridCore.html#gaae30736925e857cb467c3f5c75fdc97e">ntotal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#gab2e20ded434d1aacc44927934faabc1c">ntotal_face_dofs</a>());</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    std::vector&lt;Eigen::Triplet&lt;double&gt;&gt; triplets_ScBe;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="comment">// Source terms for the system, and for recovering cell unknowns from static condensation</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    Eigen::VectorXd GlobRHS = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#gab2e20ded434d1aacc44927934faabc1c">ntotal_face_dofs</a>());</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    Eigen::VectorXd ScRHS = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#gaae30736925e857cb467c3f5c75fdc97e">ntotal_cell_dofs</a>());</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="comment">// Global quadrature rule for the cells</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    Eigen::VectorXd cell_quadrature = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#gaae30736925e857cb467c3f5c75fdc97e">ntotal_cell_dofs</a>());</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="comment">//-------------- ASSEMBLE LOCAL CONTRIBUTIONS -------------//</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keyword">auto</span> total_measure = 0.0;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iT = 0; iT &lt; mesh-&gt;n_cells(); iT++) {</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      <a class="code" href="classHArDCore3D_1_1Cell.html">Cell</a>* iCell = mesh-&gt;cell(iT);</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    </div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;      total_measure += iCell-&gt;<a class="code" href="group__Mesh.html#ga75b939b8edadf100a35b9c7298fb5c8b">measure</a>();</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;      <span class="comment">// Total number of face degrees of freedom local to this cell (adjacent faces to the cell)</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;      <span class="keywordtype">size_t</span> nlocal_faces = iCell-&gt;<a class="code" href="group__Mesh.html#ga805584b31ee6aa7f6725075d8d16a744">n_faces</a>();</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;      <span class="keywordtype">size_t</span> face_dofs = nlocal_faces * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>();</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;      <span class="comment">// Local bilinear form and source term</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;      <span class="keywordtype">size_t</span> doeT = std::max( std::max(hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>(),size_t(hho.<a class="code" href="group__HybridCore.html#ga907fd6e5325465e94acc67c831a14cdf">Ldeg</a>())) + hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>()+1 , 2*hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>() + _deg_kappa );</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;      <span class="keywordtype">size_t</span> doeF = 2*hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>() + 1;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;      <a class="code" href="classHArDCore3D_1_1ElementQuad.html">ElementQuad</a> elquad(hho, iT, doeT, doeF);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;      aT[iT] = diffusion_operator(hho, iT, elquad);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;      Eigen::VectorXd bT = load_operator(hho, iT, elquad);</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;      <span class="comment">// Local matrix and right-hand side on the face unknowns</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;      Eigen::MatrixXd MatF = Eigen::MatrixXd::Zero(face_dofs,face_dofs);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      Eigen::VectorXd bF = Eigen::VectorXd::Zero(face_dofs);</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      <span class="keywordflow">if</span> (hho.<a class="code" href="group__HybridCore.html#gae2bb060c207a888bf97a9d2a9626e1c0">L</a>()&gt;=0) {</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    <span class="comment">// STATIC CONDENSATION OF ELEMENT UNKNOWNS</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="comment">// Perform static condensation</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    Eigen::MatrixXd ATT = aT[iT].topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>());</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    Eigen::MatrixXd ATF = aT[iT].topRightCorner(hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), face_dofs);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    Eigen::MatrixXd AFF = aT[iT].bottomRightCorner(face_dofs, face_dofs);</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    Eigen::PartialPivLU&lt;Eigen::MatrixXd&gt; invATT;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    invATT.compute(ATT);</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;          </div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    Eigen::MatrixXd invATT_ATF = invATT.solve(ATF);</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    Eigen::VectorXd invATT_bTcell = invATT.solve(bT.head(hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>()));</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    MatF = AFF - ATF.transpose() * invATT_ATF;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;          </div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    bF = bT.tail(face_dofs) - ATF.transpose() * invATT_bTcell;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                        </div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="comment">// Assemble static condensation operator</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    ScRHS.segment(iT * hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>()) = invATT_bTcell;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(); i++) {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jlF = 0; jlF &lt; nlocal_faces; jlF++) {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> jF = iCell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(jlF)-&gt;<a class="code" href="group__Mesh.html#ga5cf9000fd94ae2e7ec79245607644f1b">global_index</a>();</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jk = 0; jk &lt; hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(); jk++) {</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> jLocal = jlF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>() + jk;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> jGlobal = jF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>() + jk;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;          triplets_ScBe.emplace_back(iT * hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>() + i, jGlobal, invATT_ATF(i, jLocal));</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        }</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;      }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    }</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    <span class="comment">// BARYCENTRIC ELIMINATION OF ELEMENT UNKNOWNS</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    <span class="comment">// Create reduction matrix: 1+nlocal_faces * nlocal_faces matrix with the coefficients on the first row, and the identity below. When multiplied by the face unknowns, return cell and face unknowns</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="comment">// Note that the basis functions are constant, but not necessarily assumed to be one (which is not the case after orthonormalisation for example), which is why we have to adjust the first row.</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    Eigen::MatrixXd red_matT = Eigen::MatrixXd::Zero(1+nlocal_faces,nlocal_faces);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    red_matT.row(0) = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#a06825c5d156026d465a2798389aa952b">compute_weights</a>(iT);</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    Eigen::Vector3d xT = iCell-&gt;<a class="code" href="group__Mesh.html#ga3eb9c83b9578d3d93e94a698c37a980e">center_mass</a>();</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordtype">double</span> phiT_cst = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">cell_basis</a>(iT,0)(xT.x(), xT.y(), xT.z());</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nlocal_faces; ilF++){</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      Eigen::Vector3d xF = iCell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(ilF)-&gt;<a class="code" href="classHArDCore3D_1_1Face.html#ac5d883f4f09a9af506924638939bb35a">center_mass</a>();</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      <span class="keywordtype">size_t</span> iF = iCell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#ga5cf9000fd94ae2e7ec79245607644f1b">global_index</a>();</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;      <span class="keywordtype">double</span> phiF_cst = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#a7bacf0ebee651940baa7f04af5a47b65">face_basis</a>(iF,0)(xF.x(), xF.y(), xF.z());</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      red_matT(0,ilF) *= phiF_cst / phiT_cst;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    red_matT.bottomRightCorner(nlocal_faces,nlocal_faces) = Eigen::MatrixXd::Identity(nlocal_faces,nlocal_faces);</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    bF = red_matT.transpose() * bT;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    MatF = red_matT.transpose() * aT[iT] * red_matT;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="comment">// To recover cell unknown</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jlF = 0; jlF &lt; nlocal_faces; jlF++) {</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">size_t</span> jF = iCell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(jlF)-&gt;<a class="code" href="group__Mesh.html#ga5cf9000fd94ae2e7ec79245607644f1b">global_index</a>();</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">size_t</span> jGlobal = jF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>();</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;      triplets_ScBe.emplace_back(iT, jGlobal, red_matT(0,jlF));</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    }</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;      }</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;      <span class="comment">// Assemble local contribution into global matrix</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nlocal_faces; ilF++) {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> iF = iCell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#ga5cf9000fd94ae2e7ec79245607644f1b">global_index</a>();</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ik = 0; ik &lt; hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(); ik++) {</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">size_t</span> iLocal = ilF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>() + ik;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">size_t</span> iGlobal = iF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>() + ik;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jlF = 0; jlF &lt; nlocal_faces; jlF++) {</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> jF = iCell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(jlF)-&gt;<a class="code" href="group__Mesh.html#ga5cf9000fd94ae2e7ec79245607644f1b">global_index</a>();</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> jk = 0; jk &lt; hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(); jk++) {</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> jLocal = jlF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>() + jk;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;          <span class="keyword">const</span> <span class="keywordtype">size_t</span> jGlobal = jF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>() + jk;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;          triplets_GlobMat.emplace_back(iGlobal, jGlobal, MatF(iLocal, jLocal));</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        }</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      }</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      GlobRHS(iGlobal) += bF(iLocal);</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    }</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      }</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    </div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;      <span class="comment">// Record cell quadrature</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      <span class="keywordflow">if</span> (BC==1){</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(); i++) {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; phi_i = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">cell_basis</a>(iT, i);</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      cell_quadrature(iT * hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>() + i) = hho.<a class="code" href="group__HybridCore.html#ga1cb893746a3e8bdb80500be5c9382d96">integrate_over_cell</a>(iT, phi_i);</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    }</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;      }</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    }</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordflow">if</span> (BC==1){</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;      <span class="comment">// Neumann BC: remove a row in the matrix and fix the first degree of freedom</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      triplets_GlobMat.erase(std::remove_if(std::begin(triplets_GlobMat), std::end(triplets_GlobMat),</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                        [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) { <span class="keywordflow">return</span> (x.row() == 0); }), std::end(triplets_GlobMat));</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;      triplets_GlobMat.emplace_back(0, 0, 1);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;      GlobRHS(0) = 0;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    }</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="comment">// Assemble the global linear system (without BC), and matrix to recover statically-condensed cell dofs</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    GlobMat.setFromTriplets(std::begin(triplets_GlobMat), std::end(triplets_GlobMat));</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    ScBeMat.setFromTriplets(std::begin(triplets_ScBe), std::end(triplets_ScBe));</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">//    _assembly_time = timer.elapsed().user + timer.elapsed().system;</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    _assembly_time = timer.elapsed().wall;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="comment">//-------------- TREATMENT OF BOUNDARY CONDITIONS -------------//</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="comment">// If Dirichlet, the final system is only posed on the interior face unknowns and we have to subtract from the source</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    <span class="comment">//      term the contribution of the boundary values</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    <span class="comment">// If Neumann, the final system is posed on all face unknowns</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="keywordtype">size_t</span> nb_unknowns = 0;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <span class="keywordtype">size_t</span> nb_fixed_dofs = 0;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    Eigen::SparseMatrix&lt;double&gt; A;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    Eigen::VectorXd B;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    Eigen::VectorXd UDir;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordflow">if</span> (BC==0){</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;      <span class="comment">// Dirichlet boundary conditions</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;      nb_unknowns = hho.<a class="code" href="group__HybridCore.html#gaffef0ee3517c408e3d086956feb022bd">ninternal_face_dofs</a>();</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;      nb_fixed_dofs = hho.<a class="code" href="group__HybridCore.html#gaddeb59cc8b5d89525e27b2dee22eb70f">nboundary_face_dofs</a>();</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;      A = GlobMat.topLeftCorner(nb_unknowns, nb_unknowns);</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        </div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;      <span class="comment">// Boundary value: UDir corresponds to the L2 projection of the exact solution on the polynomial spaces on the faces</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      UDir = Eigen::VectorXd::Zero(nb_fixed_dofs);</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;      std::vector&lt;Face *&gt; b_faces = mesh-&gt;get_b_faces(); <span class="comment">// List of boundary faces</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ibF = 0; ibF &lt; mesh-&gt;n_b_faces(); ibF++){</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <a class="code" href="classHArDCore3D_1_1Face.html">Face</a>* face = b_faces[ibF]; </div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;          <span class="keywordtype">size_t</span> iF = face-&gt;<a class="code" href="group__Mesh.html#ga5cf9000fd94ae2e7ec79245607644f1b">global_index</a>();</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;          <span class="comment">// Mass matrix and boundary values</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;          <span class="keyword">auto</span> quadF = <a class="code" href="group__Quadratures.html#ga18d0a2cf574bef7d6e83760de2f38152">generate_quadrature_rule</a>(*face, 2*hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>());</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;          std::vector&lt;Eigen::ArrayXd&gt; phiF_quadF = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#af36cb92e3054b15c3b5b10fead49e925">basis_quad</a>(<span class="stringliteral">&quot;face&quot;</span>, iF, quadF, hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>());</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;          Eigen::MatrixXd MFF = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(phiF_quadF, phiF_quadF, hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), quadF, <span class="keyword">true</span>);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;          <span class="comment">// Compute (uexact, phi_i)_F for all face basis functions phi_i</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;          Eigen::VectorXd RHS_UDirF = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>());</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(); j++){</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; phi_j = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#a7bacf0ebee651940baa7f04af5a47b65">face_basis</a>(iF, j);</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;            <span class="keyword">auto</span> quadF = <a class="code" href="group__Quadratures.html#ga18d0a2cf574bef7d6e83760de2f38152">generate_quadrature_rule</a>(*face, 2*hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>()+2);</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="structHArDCore3D_1_1QuadratureNode.html">QuadratureNode</a> qF : quadF){</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;              RHS_UDirF(j) += qF.w * phi_j(qF.x, qF.y, qF.z) * exact_solution(qF.x, qF.y, qF.z);</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            }</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;          }</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;          <span class="comment">// Project exact solution</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;          UDir.segment(ibF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>()) = MFF.ldlt().solve(RHS_UDirF);</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;      }</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;      B = GlobRHS.segment(0, nb_unknowns) - GlobMat.topRightCorner(nb_unknowns, nb_fixed_dofs) * UDir;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BC==1){</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;      <span class="comment">// We will solve the complete system</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;      nb_unknowns = hho.<a class="code" href="group__HybridCore.html#gab2e20ded434d1aacc44927934faabc1c">ntotal_face_dofs</a>();</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;      A = GlobMat;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;      B = GlobRHS;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;      UDir = Eigen::VectorXd::Zero(nb_fixed_dofs);</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    }</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    <span class="comment">//-------------- SOLVE CONDENSED SYSTEM -------------//</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    timer.start();</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    Eigen::VectorXd xF = Eigen::VectorXd::Zero(nb_unknowns);</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    <span class="comment">//  if (solver_type == &quot;ma41&quot;) {</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    <span class="comment">//      Eigen::MA41&lt;Eigen::SparseMatrix&lt;double&gt;, Eigen::VectorXd&gt; solver;</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="comment">//      solver.analyzePattern(A);</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    <span class="comment">//      solver.factorize(A);</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="comment">//      xF = solver.solve(B);</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="comment">//  } else {</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    Eigen::BiCGSTAB&lt;Eigen::SparseMatrix&lt;double&gt; &gt; solver;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    solver.compute(A);</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    xF = solver.solve(B);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;#iterations:     &quot;</span> &lt;&lt; solver.iterations() &lt;&lt; std::endl;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;estimated error: &quot;</span> &lt;&lt; solver.error()      &lt;&lt; std::endl;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    <span class="comment">//  }</span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    _solving_error = (A * xF - B).norm();</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    <span class="comment">// Recover the fixed boundary values, cell unknowns (from static condensation/barycentric elimination)</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    Eigen::VectorXd Xh = Eigen::VectorXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga804722e06e20a32477cd1ae41ee6f473">ntotal_dofs</a>());</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    Xh.tail(nb_fixed_dofs) = UDir;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    Xh.segment(hho.<a class="code" href="group__HybridCore.html#gaae30736925e857cb467c3f5c75fdc97e">ntotal_cell_dofs</a>(), nb_unknowns) = xF;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <span class="keywordflow">if</span> (hho.<a class="code" href="group__HybridCore.html#gae2bb060c207a888bf97a9d2a9626e1c0">L</a>()&gt;=0) {</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;      Xh.head(hho.<a class="code" href="group__HybridCore.html#gaae30736925e857cb467c3f5c75fdc97e">ntotal_cell_dofs</a>()) = ScRHS - ScBeMat * Xh.tail(hho.<a class="code" href="group__HybridCore.html#gab2e20ded434d1aacc44927934faabc1c">ntotal_face_dofs</a>());</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;      Xh.head(hho.<a class="code" href="group__HybridCore.html#gaae30736925e857cb467c3f5c75fdc97e">ntotal_cell_dofs</a>()) = ScBeMat * Xh.tail(hho.<a class="code" href="group__HybridCore.html#gab2e20ded434d1aacc44927934faabc1c">ntotal_face_dofs</a>());</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    }</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="comment">// Only Neumann: translate to get the proper average</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordflow">if</span> (BC==1){</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;      <span class="comment">// Compute average to translate</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      <span class="keyword">auto</span> average = cell_quadrature.dot(Xh.head(hho.<a class="code" href="group__HybridCore.html#gaae30736925e857cb467c3f5c75fdc97e">ntotal_cell_dofs</a>())) / total_measure;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      <span class="keyword">auto</span> average_exact_sol = hho.<a class="code" href="group__HybridCore.html#gad6aeaa4f65c67b92307c273254f539ed">integrate_over_domain</a>([&amp;](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      <span class="keywordflow">return</span> exact_solution(x,y,z);</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    }) / total_measure;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;      <span class="comment">// Translate the cells and faces</span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;      <span class="comment">// We compute the interpolant of the constant function &quot;average_exact_sol - average&quot; </span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;      <span class="comment">// and we translate Xh by that amount</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;      std::function&lt;double(double, double, double)&gt; AveDiff = [&amp;average_exact_sol,&amp;average](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z)-&gt;<span class="keywordtype">double</span></div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    { <span class="keywordflow">return</span> average_exact_sol - average;};</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;      Eigen::VectorXd Cst = hho.<a class="code" href="group__HybridCore.html#gaa1c3baf0764f3f160759e0ffc8969dfb">interpolate</a>(AveDiff, 2*hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>()+3);</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;      Xh += Cst;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    }</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    _solving_time = timer.elapsed().user + timer.elapsed().system;  <span class="comment">// Record the final solving time</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">return</span> Xh;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  }</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;  <span class="comment">//******************************** </span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  <span class="comment">//        local diffusion matrix </span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="comment">//********************************</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;  Eigen::MatrixXd HHO_LocVarDiff::diffusion_operator(<a class="code" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a> &amp;hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore3D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad)<span class="keyword"> const </span>{</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    boost::timer::cpu_timer timeint;</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#gad4c32f117a1e67ec4a13dd9656c404e8">get_mesh_ptr</a>();</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> dimPKcell = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#aa2bdc59d150566e1b992058031509d2f">dim_Pcell</a>(hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>());</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> dimPKcell_vec = mesh-&gt;dim() * dimPKcell;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <a class="code" href="classHArDCore3D_1_1Cell.html">Cell</a>* cell = mesh-&gt;cell(iT);</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> nfacesT = cell-&gt;<a class="code" href="group__Mesh.html#ga805584b31ee6aa7f6725075d8d16a744">n_faces</a>();</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="comment">// Total number of degrees of freedom local to this cell (cell and its adjacent faces)</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keywordtype">size_t</span> local_dofs = hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>() + nfacesT * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>();</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="comment">//-------------------  Initialisatons: quadratures, mass matrices... --------------------//</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    </div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="comment">// Note: representing the gradient reconstruction GT supposes a basis for (P^k)^d. This basis can be</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="comment">//  built from the basis (phi_i)_i of P^k, by working component-by-component:</span></div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    <span class="comment">//      (phi_1 e_1, ..., phi_N e_1, phi_1 e_2, ..., phi_N e_2, ...),</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="comment">//      where e_1=[1 0], e_2=[0 1]... is the canonical basis of R^d</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="comment">//  Hence, the first dimPKcell functions are on the first component of R^d, the next dimPKcell on the second</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="comment">//      component etc.</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    <span class="comment">//  We do not explicitly build this basis function, but we compute the values of these functions at the</span></div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="comment">//      quadrature nodes, using the values computed for the scalar basis functions</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="comment">// QUADRATURES</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="comment">// Cell quadrature nodes, and values of cell basis functions (up to degree K+1) and gradients thereof.</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <span class="keyword">auto</span> quadT = elquad.<a class="code" href="group__HybridCore.html#ga9676c87f42764a058c9d7aecd2ce44cd">get_quadT</a>();</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    std::vector&lt;Eigen::ArrayXd&gt; phiT_quadT = elquad.<a class="code" href="group__HybridCore.html#gaafce6cb00f061fe1159a9972b73d3bb9">get_phiT_quadT</a>();</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    std::vector&lt;Eigen::ArrayXXd&gt; dphiT_quadT = elquad.<a class="code" href="group__HybridCore.html#gab0450891cb0d96686256c31e87948374">get_dphiT_quadT</a>();</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="comment">// Vector basis functions (up to degree K) at the quadrature nodes. Given that the chosen implicit vector basis</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="comment">//  function, their values at the quadrature nodes are obtained from those of the scalar basis functions</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    std::vector&lt;Eigen::ArrayXXd&gt; vec_phiT_quadT = elquad.<a class="code" href="classHArDCore3D_1_1ElementQuad.html#a0df097bcb15554c9f9ee752f04c14f95">get_vec_phiT_quadT</a>(hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>());</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    </div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="comment">// Diffusion tensor at the quadrature nodes</span></div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    std::vector&lt;Eigen::Matrix3d&gt; kappaT_quadT(quadT.size());</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    std::transform(quadT.begin(), quadT.end(), kappaT_quadT.begin(),</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;           [<span class="keyword">this</span>,&amp;cell](<a class="code" href="structHArDCore3D_1_1QuadratureNode.html">QuadratureNode</a> qr) -&gt; Eigen::MatrixXd { <span class="keywordflow">return</span> kappa(qr.x, qr.y, qr.z, cell); });</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="comment">// MASS MATRICES</span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="comment">// Scalar cell mass matrix (phi_i,phi_j)_T up to degree max(L,K) * (K+1), and </span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="comment">// Vector cell mass matrix (Phi_i,Phi_j)_T up to degree K*K [this one is block diagonal]</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordtype">size_t</span> maxdimPKL = std::max(hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), dimPKcell);</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    _itime[0] += timeint.elapsed().user + timeint.elapsed().system;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    timeint.start();</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    Eigen::MatrixXd MTT = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(phiT_quadT, phiT_quadT, maxdimPKL, hho.<a class="code" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a>(), quadT, <span class="keyword">true</span>);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    Eigen::MatrixXd VecMTT = Eigen::MatrixXd::Zero(dimPKcell_vec, dimPKcell_vec);</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> r=0; r &lt; mesh-&gt;dim(); r++){</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;      VecMTT.block(r*dimPKcell, r*dimPKcell, dimPKcell, dimPKcell) = MTT.topLeftCorner(dimPKcell, dimPKcell);</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    } </div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    <span class="comment">// Face mass matrices:</span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <span class="comment">// MFF[ilF]: face-face mass on face with local number ilF, up to degree K*K</span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="comment">// MFT[ilF]: face-cell mass on face with local number ilF, up to degree K*(K+1)</span></div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="comment">// MTT_on_F[ilF]: cell-cell mass on face with local number ilF, up to degree K*L</span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;    std::vector&lt;Eigen::MatrixXd&gt; MFF(nfacesT, Eigen::MatrixXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>()));</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    std::vector&lt;Eigen::MatrixXd&gt; MFT(nfacesT, Eigen::MatrixXd::Zero(hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a>()));</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    std::vector&lt;Eigen::MatrixXd&gt; MTT_on_F(nfacesT, Eigen::MatrixXd::Zero(dimPKcell, hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>()));</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    _itime[1] += timeint.elapsed().user + timeint.elapsed().system;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    timeint.start();</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nfacesT; ilF++) {</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;      <span class="comment">// Face quadrature nodes and values of cell and face basis functions (and gradients) at these nodes</span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;      <span class="keyword">auto</span> quadF = elquad.<a class="code" href="group__HybridCore.html#ga7eb693a2f8d58d04b0e653cb952e59f2">get_quadF</a>(ilF);</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;      std::vector&lt;Eigen::ArrayXd&gt; phiT_quadF = elquad.<a class="code" href="group__HybridCore.html#gab6349fe3a8eb0d4070cd2bd82742bdcc">get_phiT_quadF</a>(ilF);</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;      std::vector&lt;Eigen::ArrayXd&gt; phiF_quadF = elquad.<a class="code" href="group__HybridCore.html#gad9c2ba4cdbfda183ee00ab059d8885e5">get_phiF_quadF</a>(ilF);</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;      <span class="comment">// Mass matrices</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      MFF[ilF] = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(phiF_quadF, phiF_quadF, hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), quadF, <span class="keyword">true</span>);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;      MFT[ilF] = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(phiF_quadF, phiT_quadF, hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a>(), quadF, <span class="keyword">false</span>);</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;      MTT_on_F[ilF] = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(phiT_quadF, phiT_quadF, dimPKcell, hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), quadF, <span class="keyword">false</span>);</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    }</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    <span class="comment">// STIFNESS mass-matrices (and the like): (\nabla phi_i,\nabla phi_j)_T up to degree (K+1)*(K+1)</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    <span class="comment">//  and (\nabla phi_i, Phi_j)_T up to degree (K+1)*K</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    Eigen::MatrixXd StiffT = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(dphiT_quadT, dphiT_quadT, hho.<a class="code" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a>(), quadT, <span class="keyword">true</span>);  </div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;    Eigen::MatrixXd MdphiT_PhiT = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(dphiT_quadT, vec_phiT_quadT, hho.<a class="code" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a>(), dimPKcell_vec, quadT, <span class="keyword">false</span>);</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    _itime[2] += timeint.elapsed().user + timeint.elapsed().system;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    timeint.start();</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    <span class="comment">//-------------------- Compute GT, matrix of full gradient reconstruction ---------//</span></div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="comment">// Right-hand side, starting with volumetric term (Phi_i, \nabla phi_j)_T</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    Eigen::MatrixXd RHS_GT = Eigen::MatrixXd::Zero(dimPKcell_vec, local_dofs);</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    RHS_GT.topLeftCorner(dimPKcell_vec, hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>()) = (MdphiT_PhiT.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), dimPKcell_vec)).transpose();</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    <span class="comment">// Boundary terms</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> r=0; r &lt; mesh-&gt;dim(); r++){</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nfacesT; ilF++) {</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    <span class="comment">// Offset for face unknowns</span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">size_t</span> offset_F = hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>() + ilF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>();</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; nTF = cell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#a648c17f293071f01180c4014adb5a25b">face_normal</a>(ilF);</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="comment">// Contribution of cell unknowns, and then face unknowns on F</span></div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    RHS_GT.block(r*dimPKcell, 0, dimPKcell, hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>()) -= nTF(r) * MTT_on_F[ilF];</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    RHS_GT.block(r*dimPKcell, offset_F, dimPKcell, hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>()) += </div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;      nTF(r) * (MFT[ilF].topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), dimPKcell)).transpose();</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;      }</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    }</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="comment">// Compute GT</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    Eigen::MatrixXd GT = (VecMTT.ldlt()).<a class="code" href="group__HHO__LocVarDiff.html#gab01c6aad8ad6264f67f866ec26c8055d">solve</a>(RHS_GT);</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    <span class="comment">//------------- Consistent contribution (K GT, GT)_T to the local bilinear form ------//</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="comment">//  Weighted mass matrix    (K Phi_i, Phi_j)_T of the basis (Phi_i)_i of (P^k)^d</span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    Eigen::MatrixXd kappaVecMTT = Eigen::MatrixXd::Zero(dimPKcell_vec, dimPKcell_vec);</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    kappaVecMTT = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a>(vec_phiT_quadT, vec_phiT_quadT, dimPKcell_vec, dimPKcell_vec, quadT, <span class="keyword">true</span>, kappaT_quadT);</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;    Eigen::MatrixXd ATF = GT.transpose() * kappaVecMTT * GT;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    <span class="comment">//------------- Compute PT, matrix of potential reconstruction, using GT ------//</span></div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    <span class="comment">// We write that \nabla pT = projection on \nabla P^{k+1} of GT, and add the closure relation:</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    <span class="comment">// (nabla pT v, nabla w)_T + lambda_T(p_T v,1)_T(w,1)_T = (GT v,\nabla w)_T + lambda_T(v_T,1)_T(w,1)_T</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="comment">// Right-hand side, starting with volumetric term</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    Eigen::MatrixXd RHS_PT = MdphiT_PhiT * GT;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    </div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    <span class="comment">// Vector LT of (phi_j,1)_T for phi_j up to degree K+1, and LT^t*LT, for the closure relation</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    Eigen::VectorXd LT = (MTT.row(0)).transpose();</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    Eigen::MatrixXd LTtLT = LT * (LT.transpose());</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    <span class="keywordtype">double</span> scalT = StiffT.trace() / std::pow(LT.norm(), 2);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    <span class="comment">// Add closure relation and compute PT</span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    RHS_PT.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>()) += </div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;      scalT * LTtLT.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>());</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    Eigen::MatrixXd PT = ((StiffT + scalT*LTtLT).ldlt()).<a class="code" href="group__HHO__LocVarDiff.html#gab01c6aad8ad6264f67f866ec26c8055d">solve</a>(RHS_PT);</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="comment">//-------------------- Compute stabilisation term sT ---------//</span></div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    Eigen::MatrixXd STF = Eigen::MatrixXd::Zero(local_dofs, local_dofs);</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;    <span class="comment">// Cell residual delta_T^l = pi_T^l (rT uT) - u_T</span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    Eigen::MatrixXd MTT_LKp1 = MTT.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">nhighorder_dofs</a>());</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    Eigen::MatrixXd MTT_LL = MTT.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>());</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    Eigen::MatrixXd deltaTL = MTT_LL.ldlt().solve( MTT_LKp1 * PT );</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    deltaTL.topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>()) -=</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;      Eigen::MatrixXd::Identity(hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>());</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; nfacesT; ilF++) {</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        <span class="comment">// Two options for stabilisation: diameter of edge, or ratio measure cell/measure edge</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="comment">//      double dTF = cell-&gt;face(ilF)-&gt;diam();</span></div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;        <span class="keywordtype">double</span> dTF = cell-&gt;<a class="code" href="group__Mesh.html#ga75b939b8edadf100a35b9c7298fb5c8b">measure</a>() / cell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#gad8284631ae078f8f5a15147b7b1014a1">measure</a>();</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    Eigen::Vector3d xF = cell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(ilF)-&gt;<a class="code" href="classHArDCore3D_1_1Face.html#ac5d883f4f09a9af506924638939bb35a">center_mass</a>();</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;      <span class="keyword">auto</span> kappa_TF = kappa(xF.x(), xF.y(), xF.z(), cell).trace();</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;      <span class="comment">// Face residual delta_TF^k = pi_F^k (rT uT) - u_F</span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;      Eigen::MatrixXd MFFinv = MFF[ilF].inverse();</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;      Eigen::MatrixXd deltaTFK = MFFinv * MFT[ilF] * PT;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;      deltaTFK.block(0, hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>() + ilF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>()) -=</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;        Eigen::MatrixXd::Identity(hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>());</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;      <span class="comment">// Stabilisation term</span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;      Eigen::MatrixXd deltaTFK_minus_deltaTL = deltaTFK - MFFinv * MFT[ilF].topLeftCorner(hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(), hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>()) * deltaTL;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        STF += (kappa_TF / dTF) * deltaTFK_minus_deltaTL.transpose() * MFF[ilF] *  deltaTFK_minus_deltaTL;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    }</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    _itime[3] += timeint.elapsed().user + timeint.elapsed().system;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;    <span class="comment">// Adjust local bilinear form with stabilisation term</span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;    ATF += STF;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;    <span class="keywordflow">return</span> ATF;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  }</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;  <span class="comment">//******************************** </span></div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  <span class="comment">//        local load term </span></div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;  <span class="comment">//********************************</span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;  Eigen::VectorXd HHO_LocVarDiff::load_operator(<a class="code" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a> &amp;hho, <span class="keyword">const</span> <span class="keywordtype">size_t</span> iT, <span class="keyword">const</span> <a class="code" href="classHArDCore3D_1_1ElementQuad.html">ElementQuad</a> &amp;elquad)<span class="keyword"> const </span>{</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;    <span class="comment">// Load for the cell DOFs (first indices) and face DOFs (last indices)</span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#gad4c32f117a1e67ec4a13dd9656c404e8">get_mesh_ptr</a>();</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;    <a class="code" href="classHArDCore3D_1_1Cell.html">Cell</a>* cell = mesh-&gt;cell(iT);</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    <span class="keywordtype">size_t</span> cell_face_dofs = hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>() + cell-&gt;<a class="code" href="group__Mesh.html#ga805584b31ee6aa7f6725075d8d16a744">n_faces</a>()*hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>();</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    Eigen::VectorXd b = Eigen::VectorXd::Zero(cell_face_dofs);</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    <span class="comment">// Quadrature nodes and values of cell basis functions at these nodes</span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;    <span class="keyword">auto</span> quadT = elquad.<a class="code" href="group__HybridCore.html#ga9676c87f42764a058c9d7aecd2ce44cd">get_quadT</a>();</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;    <span class="keywordtype">size_t</span> nbq = quadT.size();</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;    std::vector&lt;Eigen::ArrayXd&gt; phiT_quadT = elquad.<a class="code" href="group__HybridCore.html#gaafce6cb00f061fe1159a9972b73d3bb9">get_phiT_quadT</a>();</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    <span class="comment">// Value of source times quadrature weights at the quadrature nodes</span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;    Eigen::ArrayXd weight_source_quad = Eigen::ArrayXd::Zero(nbq);</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iqn = 0; iqn &lt; nbq; iqn++){</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;      weight_source_quad(iqn) = quadT[iqn].w * source(quadT[iqn].x, quadT[iqn].y, quadT[iqn].z, cell);</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    }</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>(); i++){</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;      b(i) = (weight_source_quad * phiT_quadT[i]).sum();</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    }</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    <span class="comment">// Boundary values, if we have a boundary cell</span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    <span class="keywordflow">if</span> (cell-&gt;<a class="code" href="group__Mesh.html#gab401dd009e7f13008b03cc2080d93449">is_boundary</a>()){</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;      <span class="keywordflow">if</span> (BC==0){</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="comment">// Dirichlet BCs: no source terms on these faces</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (BC==1) {</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="comment">// Neumann BCs</span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ilF = 0; ilF &lt; cell-&gt;<a class="code" href="group__Mesh.html#ga805584b31ee6aa7f6725075d8d16a744">n_faces</a>(); ilF++) {</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <a class="code" href="classHArDCore3D_1_1Face.html">Face</a>* face = cell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(ilF);</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">size_t</span> iF = face-&gt;<a class="code" href="group__Mesh.html#ga5cf9000fd94ae2e7ec79245607644f1b">global_index</a>(); </div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;      <span class="comment">// BC on boundary faces</span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;      <span class="keywordflow">if</span> (cell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">face</a>(ilF)-&gt;<a class="code" href="group__Mesh.html#ga8f69df15c3c76b4f80f51231ede670f5">is_boundary</a>()){</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <span class="comment">// Offset for face unknowns</span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">size_t</span> offset_F = hho.<a class="code" href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">nlocal_cell_dofs</a>() + ilF * hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>();</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        <span class="comment">// Normal to the face</span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; nTF = cell-&gt;<a class="code" href="classHArDCore3D_1_1Cell.html#a648c17f293071f01180c4014adb5a25b">face_normal</a>(ilF);</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        <span class="comment">// for each DOF of the boundary face</span></div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; hho.<a class="code" href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">nlocal_face_dofs</a>(); i++){</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;          <span class="keyword">const</span> <span class="keyword">auto</span>&amp; phi_i = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#a7bacf0ebee651940baa7f04af5a47b65">face_basis</a>(iF, i);</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;          <span class="keyword">auto</span> quadF = <a class="code" href="group__Quadratures.html#ga18d0a2cf574bef7d6e83760de2f38152">generate_quadrature_rule</a>(*face, _deg_kappa+ 2*hho.<a class="code" href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">K</a>()+2);</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;          std::function&lt;double(double,double,double)&gt; Kgrad_n = [&amp;](<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">double</span> z){</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        <span class="keywordflow">return</span> nTF.dot(kappa(x,y,z,cell) * grad_exact_solution(x,y,z,cell)) * phi_i(x,y,z);</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;          };</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;          <span class="keywordflow">for</span> (<a class="code" href="structHArDCore3D_1_1QuadratureNode.html">QuadratureNode</a> qF : quadF){</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        b(offset_F + i) += qF.w * Kgrad_n(qF.x, qF.y, qF.z);</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;          }</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;        }</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;      }</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    }</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;      }</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    }</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    </div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    <span class="keywordflow">return</span> b;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;  }</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div><div class="line"><a name="l00626"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#gab04749bad041c0ed9e91c54f262d42e1">  626</a></span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#gab04749bad041c0ed9e91c54f262d42e1">HHO_LocVarDiff::EnergyNorm</a>(<a class="code" href="classHArDCore3D_1_1HybridCore.html">HybridCore</a>&amp; hho, <span class="keyword">const</span> Eigen::VectorXd Xh) {</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> mesh = hho.<a class="code" href="group__HybridCore.html#gad4c32f117a1e67ec4a13dd9656c404e8">get_mesh_ptr</a>();</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    <span class="keywordtype">double</span> value = 0.0;</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iT = 0; iT &lt; mesh-&gt; n_cells(); iT++) {</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;      Eigen::VectorXd XTF = hho.<a class="code" href="classHArDCore3D_1_1HybridCore.html#a02b46a742045262030431b73eb112f9c">restr</a>(Xh, iT);</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;      value += XTF.transpose() * aT[iT] * XTF;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    }</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    <span class="keywordflow">return</span> sqrt(value);</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  }</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;</div><div class="line"><a name="l00640"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga4232eab7b9753215b506d5ce701c4f4f">  640</a></span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga4232eab7b9753215b506d5ce701c4f4f">HHO_LocVarDiff::get_assembly_time</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    <span class="keywordflow">return</span> double(_assembly_time) * pow(10, -9);</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  }</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;</div><div class="line"><a name="l00644"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga10971b2952ab54d336127a43f5ed9b29">  644</a></span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga10971b2952ab54d336127a43f5ed9b29">HHO_LocVarDiff::get_solving_time</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <span class="keywordflow">return</span> double(_solving_time) * pow(10, -9);</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;  }</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;</div><div class="line"><a name="l00648"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#gae66d0e79903e2ca077ff2515c20d7d2e">  648</a></span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#gae66d0e79903e2ca077ff2515c20d7d2e">HHO_LocVarDiff::get_itime</a>(<span class="keywordtype">size_t</span> idx)<span class="keyword"> const </span>{</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;    <span class="keywordflow">return</span> double(_itime[idx]) * pow(10, -9);</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  }</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;</div><div class="line"><a name="l00652"></a><span class="lineno"><a class="line" href="group__HHO__LocVarDiff.html#ga22542468093ee4e8e24d8c0a27946f8f">  652</a></span>&#160;  <span class="keywordtype">double</span> <a class="code" href="group__HHO__LocVarDiff.html#ga22542468093ee4e8e24d8c0a27946f8f">HHO_LocVarDiff::get_solving_error</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    <span class="keywordflow">return</span> _solving_error;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;  }</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;} <span class="comment">// end of namespace HArDCore3D</span></div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;<span class="preprocessor">#endif //_HHO_LOCVARDIFF_HPP</span></div><div class="ttc" id="group__HybridCore_html_gab0450891cb0d96686256c31e87948374"><div class="ttname"><a href="group__HybridCore.html#gab0450891cb0d96686256c31e87948374">HArDCore3D::ElementQuad::get_dphiT_quadT</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXXd &gt; get_dphiT_quadT() const</div><div class="ttdoc">Returns values of gradients of cell basis functions at cell quadrature rules in cell. </div><div class="ttdef"><b>Definition:</b> elementquad.hpp:118</div></div>
<div class="ttc" id="group__HybridCore_html_ga7eb693a2f8d58d04b0e653cb952e59f2"><div class="ttname"><a href="group__HybridCore.html#ga7eb693a2f8d58d04b0e653cb952e59f2">HArDCore3D::ElementQuad::get_quadF</a></div><div class="ttdeci">QuadratureRule get_quadF(size_t ilF) const</div><div class="ttdoc">Returns quadrature rules on face with local number ilF. </div><div class="ttdef"><b>Definition:</b> elementquad.hpp:119</div></div>
<div class="ttc" id="group__HybridCore_html_gaa1c3baf0764f3f160759e0ffc8969dfb"><div class="ttname"><a href="group__HybridCore.html#gaa1c3baf0764f3f160759e0ffc8969dfb">HArDCore3D::HybridCore::interpolate</a></div><div class="ttdeci">Eigen::VectorXd interpolate(const Function &amp;f, size_t doe) const</div><div class="ttdoc">Compute the interpolant in the discrete space of a continuous function. </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:358</div></div>
<div class="ttc" id="classHArDCore3D_1_1HybridCore_html_a7bacf0ebee651940baa7f04af5a47b65"><div class="ttname"><a href="classHArDCore3D_1_1HybridCore.html#a7bacf0ebee651940baa7f04af5a47b65">HArDCore3D::HybridCore::face_basis</a></div><div class="ttdeci">const face_basis_type &amp; face_basis(size_t iF, size_t i) const</div><div class="ttdoc">Return a reference to the i&amp;#39;th basis function of the face iF. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:113</div></div>
<div class="ttc" id="group__HybridCore_html_gaae30736925e857cb467c3f5c75fdc97e"><div class="ttname"><a href="group__HybridCore.html#gaae30736925e857cb467c3f5c75fdc97e">HArDCore3D::HybridCore::ntotal_cell_dofs</a></div><div class="ttdeci">size_t ntotal_cell_dofs() const</div><div class="ttdoc">total number of cell degrees of freedom </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:441</div></div>
<div class="ttc" id="group__HybridCore_html_ga07b815b769bba05753666f6bf900fdc5"><div class="ttname"><a href="group__HybridCore.html#ga07b815b769bba05753666f6bf900fdc5">HArDCore3D::HybridCore::nhighorder_dofs</a></div><div class="ttdeci">size_t nhighorder_dofs() const</div><div class="ttdoc">total number of cell degrees of freedom with polynomials up to order k+1 </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:444</div></div>
<div class="ttc" id="classHArDCore3D_1_1HybridCore_html_af36cb92e3054b15c3b5b10fead49e925"><div class="ttname"><a href="classHArDCore3D_1_1HybridCore.html#af36cb92e3054b15c3b5b10fead49e925">HArDCore3D::HybridCore::basis_quad</a></div><div class="ttdeci">const std::vector&lt; Eigen::ArrayXd &gt; basis_quad(const std::string cellface, const size_t iTF, const QuadratureRule quad, const size_t degree, const std::string type_basis=&quot;basis&quot;) const</div><div class="ttdoc">Computes (cell or face) basis functions at the given quadrature nodes. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:392</div></div>
<div class="ttc" id="group__Mesh_html_ga8f69df15c3c76b4f80f51231ede670f5"><div class="ttname"><a href="group__Mesh.html#ga8f69df15c3c76b4f80f51231ede670f5">HArDCore3D::Face::is_boundary</a></div><div class="ttdeci">bool is_boundary() const</div><div class="ttdoc">getter to see if the face is a boundary face </div><div class="ttdef"><b>Definition:</b> face.hpp:113</div></div>
<div class="ttc" id="group__HybridCore_html_gae2bb060c207a888bf97a9d2a9626e1c0"><div class="ttname"><a href="group__HybridCore.html#gae2bb060c207a888bf97a9d2a9626e1c0">HArDCore3D::HybridCore::L</a></div><div class="ttdeci">int L() const</div><div class="ttdoc">polynomial degree of cell unknowns </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:453</div></div>
<div class="ttc" id="group__HybridCore_html_ga228678f9bf8057025f3c220e40cab209"><div class="ttname"><a href="group__HybridCore.html#ga228678f9bf8057025f3c220e40cab209">HArDCore3D::HybridCore::nlocal_cell_dofs</a></div><div class="ttdeci">size_t nlocal_cell_dofs() const</div><div class="ttdoc">number of degrees of freedom in each cell (dimension of polynomial space) </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:440</div></div>
<div class="ttc" id="group__HHO__LocVarDiff_html_gab04749bad041c0ed9e91c54f262d42e1"><div class="ttname"><a href="group__HHO__LocVarDiff.html#gab04749bad041c0ed9e91c54f262d42e1">HArDCore3D::HHO_LocVarDiff::EnergyNorm</a></div><div class="ttdeci">double EnergyNorm(HybridCore &amp;hho, const Eigen::VectorXd Xh)</div><div class="ttdoc">Discrete energy norm (associated to the diffusion operator) of an hybrid function. </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:626</div></div>
<div class="ttc" id="group__Mesh_html_ga5cf9000fd94ae2e7ec79245607644f1b"><div class="ttname"><a href="group__Mesh.html#ga5cf9000fd94ae2e7ec79245607644f1b">HArDCore3D::Face::global_index</a></div><div class="ttdeci">size_t global_index() const</div><div class="ttdoc">returns the face global index </div><div class="ttdef"><b>Definition:</b> face.hpp:109</div></div>
<div class="ttc" id="classHArDCore3D_1_1ElementQuad_html_a0df097bcb15554c9f9ee752f04c14f95"><div class="ttname"><a href="classHArDCore3D_1_1ElementQuad.html#a0df097bcb15554c9f9ee752f04c14f95">HArDCore3D::ElementQuad::get_vec_phiT_quadT</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXXd &gt; get_vec_phiT_quadT(size_t degree) const</div><div class="ttdoc">Builds on the fly the values of cell basis functions at cell quadrature nodes. The vector basis is ob...</div><div class="ttdef"><b>Definition:</b> elementquad.cpp:55</div></div>
<div class="ttc" id="group__HybridCore_html_gad6aeaa4f65c67b92307c273254f539ed"><div class="ttname"><a href="group__HybridCore.html#gad6aeaa4f65c67b92307c273254f539ed">HArDCore3D::HybridCore::integrate_over_domain</a></div><div class="ttdeci">double integrate_over_domain(const Function &amp;f) const</div><div class="ttdoc">Integrates a function over the domaine. Use with parcimony, expensive (re-compute quadratures) ...</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:342</div></div>
<div class="ttc" id="namespaceHArDCore3D_html"><div class="ttname"><a href="namespaceHArDCore3D.html">HArDCore3D</a></div><div class="ttdef"><b>Definition:</b> HHO_Diffusion.hpp:49</div></div>
<div class="ttc" id="classHArDCore3D_1_1HHO__LocVarDiff_html"><div class="ttname"><a href="classHArDCore3D_1_1HHO__LocVarDiff.html">HArDCore3D::HHO_LocVarDiff</a></div><div class="ttdoc">The HHO_LocVarDiff class provides tools to implement the HHO method for the diffusion problem...</div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:61</div></div>
<div class="ttc" id="group__HybridCore_html_gab2e20ded434d1aacc44927934faabc1c"><div class="ttname"><a href="group__HybridCore.html#gab2e20ded434d1aacc44927934faabc1c">HArDCore3D::HybridCore::ntotal_face_dofs</a></div><div class="ttdeci">size_t ntotal_face_dofs() const</div><div class="ttdoc">total number of face degrees of freedom </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:443</div></div>
<div class="ttc" id="classHArDCore3D_1_1Cell_html"><div class="ttname"><a href="classHArDCore3D_1_1Cell.html">HArDCore3D::Cell</a></div><div class="ttdoc">The Cell class provides description of a cell. </div><div class="ttdef"><b>Definition:</b> cell.hpp:32</div></div>
<div class="ttc" id="classHArDCore3D_1_1HybridCore_html_aa2bdc59d150566e1b992058031509d2f"><div class="ttname"><a href="classHArDCore3D_1_1HybridCore.html#aa2bdc59d150566e1b992058031509d2f">HArDCore3D::HybridCore::dim_Pcell</a></div><div class="ttdeci">size_t dim_Pcell(const size_t m) const</div><div class="ttdoc">Compute the size of the basis of 3-variate polynomials up to degree m. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:87</div></div>
<div class="ttc" id="classHArDCore3D_1_1HybridCore_html_aa5c203c11a661933930a33335b0e2479"><div class="ttname"><a href="classHArDCore3D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">HArDCore3D::HybridCore::gram_matrix</a></div><div class="ttdeci">Eigen::MatrixXd gram_matrix(const std::vector&lt; Eigen::ArrayXd &gt; &amp;f_quad, const std::vector&lt; Eigen::ArrayXd &gt; &amp;g_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; double &gt; L2weight={}) const</div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:323</div></div>
<div class="ttc" id="structHArDCore3D_1_1QuadratureNode_html"><div class="ttname"><a href="structHArDCore3D_1_1QuadratureNode.html">HArDCore3D::QuadratureNode</a></div><div class="ttdoc">Description of one node and one weight from a quadrature rule. </div><div class="ttdef"><b>Definition:</b> quadraturerule.hpp:41</div></div>
<div class="ttc" id="group__Mesh_html_ga75b939b8edadf100a35b9c7298fb5c8b"><div class="ttname"><a href="group__Mesh.html#ga75b939b8edadf100a35b9c7298fb5c8b">HArDCore3D::Cell::measure</a></div><div class="ttdeci">double measure() const</div><div class="ttdoc">returns area of cell </div><div class="ttdef"><b>Definition:</b> cell.hpp:120</div></div>
<div class="ttc" id="classHArDCore3D_1_1HHO__LocVarDiff_html_a13003c1e92aab2a21e3055e2fd7104f8"><div class="ttname"><a href="classHArDCore3D_1_1HHO__LocVarDiff.html#a13003c1e92aab2a21e3055e2fd7104f8">HArDCore3D::HHO_LocVarDiff::grad_function_type</a></div><div class="ttdeci">std::function&lt; Eigen::Vector3d(double, double, double, Cell *)&gt; grad_function_type</div><div class="ttdoc">type for gradient </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:67</div></div>
<div class="ttc" id="group__Mesh_html_ga3eb9c83b9578d3d93e94a698c37a980e"><div class="ttname"><a href="group__Mesh.html#ga3eb9c83b9578d3d93e94a698c37a980e">HArDCore3D::Cell::center_mass</a></div><div class="ttdeci">Vector3d center_mass() const</div><div class="ttdoc">returns the center of mass of the cell </div><div class="ttdef"><b>Definition:</b> cell.hpp:118</div></div>
<div class="ttc" id="group__HybridCore_html_ga804722e06e20a32477cd1ae41ee6f473"><div class="ttname"><a href="group__HybridCore.html#ga804722e06e20a32477cd1ae41ee6f473">HArDCore3D::HybridCore::ntotal_dofs</a></div><div class="ttdeci">size_t ntotal_dofs() const</div><div class="ttdoc">Total number of degrees of freedom. </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:449</div></div>
<div class="ttc" id="classHArDCore3D_1_1Face_html_ac5d883f4f09a9af506924638939bb35a"><div class="ttname"><a href="classHArDCore3D_1_1Face.html#ac5d883f4f09a9af506924638939bb35a">HArDCore3D::Face::center_mass</a></div><div class="ttdeci">Vector3d center_mass() const</div><div class="ttdoc">get the center of mass of the face </div><div class="ttdef"><b>Definition:</b> face.cpp:114</div></div>
<div class="ttc" id="group__HHO__LocVarDiff_html_ga22542468093ee4e8e24d8c0a27946f8f"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga22542468093ee4e8e24d8c0a27946f8f">HArDCore3D::HHO_LocVarDiff::get_solving_error</a></div><div class="ttdeci">double get_solving_error() const</div><div class="ttdoc">residual after solving the scheme </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:652</div></div>
<div class="ttc" id="classHArDCore3D_1_1Face_html"><div class="ttname"><a href="classHArDCore3D_1_1Face.html">HArDCore3D::Face</a></div><div class="ttdoc">The Face class provides description of an edge. </div><div class="ttdef"><b>Definition:</b> face.hpp:32</div></div>
<div class="ttc" id="group__HybridCore_html_ga5c5d20faf615bca6e170961a61464fb2"><div class="ttname"><a href="group__HybridCore.html#ga5c5d20faf615bca6e170961a61464fb2">HArDCore3D::HybridCore::K</a></div><div class="ttdeci">size_t K() const</div><div class="ttdoc">polynomial degree of edge unknowns </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:452</div></div>
<div class="ttc" id="group__HybridCore_html_gaafce6cb00f061fe1159a9972b73d3bb9"><div class="ttname"><a href="group__HybridCore.html#gaafce6cb00f061fe1159a9972b73d3bb9">HArDCore3D::ElementQuad::get_phiT_quadT</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXd &gt; get_phiT_quadT() const</div><div class="ttdoc">Returns values of cell basis functions at cell quadrature rules in cell. </div><div class="ttdef"><b>Definition:</b> elementquad.hpp:117</div></div>
<div class="ttc" id="classHArDCore3D_1_1HHO__LocVarDiff_html_a57cf83c67a9bcd71822a4ebdfbe0f0ce"><div class="ttname"><a href="classHArDCore3D_1_1HHO__LocVarDiff.html#a57cf83c67a9bcd71822a4ebdfbe0f0ce">HArDCore3D::HHO_LocVarDiff::solution_function_type</a></div><div class="ttdeci">std::function&lt; double(double, double, double)&gt; solution_function_type</div><div class="ttdoc">type for solution </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:65</div></div>
<div class="ttc" id="group__Quadratures_html_ga18d0a2cf574bef7d6e83760de2f38152"><div class="ttname"><a href="group__Quadratures.html#ga18d0a2cf574bef7d6e83760de2f38152">HArDCore3D::generate_quadrature_rule</a></div><div class="ttdeci">QuadratureRule generate_quadrature_rule(const Cell &amp;T, const int doe, const bool force_split)</div><div class="ttdoc">Generate quadrature rule on mesh element. </div><div class="ttdef"><b>Definition:</b> quadraturerule.cpp:13</div></div>
<div class="ttc" id="group__HybridCore_html_ga1cb893746a3e8bdb80500be5c9382d96"><div class="ttname"><a href="group__HybridCore.html#ga1cb893746a3e8bdb80500be5c9382d96">HArDCore3D::HybridCore::integrate_over_cell</a></div><div class="ttdeci">double integrate_over_cell(const size_t iT, const Function &amp;f) const</div><div class="ttdoc">Integrates a function over a cell. Use with parcimony, expensive (re-compute quadratures) ...</div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:324</div></div>
<div class="ttc" id="classHArDCore3D_1_1HybridCore_html_a34242db07cc2b3c3b867d9e4580b634d"><div class="ttname"><a href="classHArDCore3D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">HArDCore3D::HybridCore::cell_basis</a></div><div class="ttdeci">const cell_basis_type &amp; cell_basis(size_t iT, size_t i) const</div><div class="ttdoc">Return a reference to the i&amp;#39;th basis function of the cell iT. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:107</div></div>
<div class="ttc" id="classHArDCore3D_1_1HybridCore_html"><div class="ttname"><a href="classHArDCore3D_1_1HybridCore.html">HArDCore3D::HybridCore</a></div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:66</div></div>
<div class="ttc" id="group__HybridCore_html_gaffef0ee3517c408e3d086956feb022bd"><div class="ttname"><a href="group__HybridCore.html#gaffef0ee3517c408e3d086956feb022bd">HArDCore3D::HybridCore::ninternal_face_dofs</a></div><div class="ttdeci">size_t ninternal_face_dofs() const</div><div class="ttdoc">total number of face degrees of freedom for internal faces </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:447</div></div>
<div class="ttc" id="classHArDCore3D_1_1HHO__LocVarDiff_html_a478a09a65f66428a614412e7d308ffcd"><div class="ttname"><a href="classHArDCore3D_1_1HHO__LocVarDiff.html#a478a09a65f66428a614412e7d308ffcd">HArDCore3D::HHO_LocVarDiff::source_function_type</a></div><div class="ttdeci">std::function&lt; double(double, double, double, Cell *)&gt; source_function_type</div><div class="ttdoc">type for source </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:66</div></div>
<div class="ttc" id="group__HHO__LocVarDiff_html_gab01c6aad8ad6264f67f866ec26c8055d"><div class="ttname"><a href="group__HHO__LocVarDiff.html#gab01c6aad8ad6264f67f866ec26c8055d">HArDCore3D::HHO_LocVarDiff::solve</a></div><div class="ttdeci">Eigen::VectorXd solve(HybridCore &amp;hho)</div><div class="ttdoc">Assemble and solve the scheme. </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:129</div></div>
<div class="ttc" id="group__Mesh_html_gad8284631ae078f8f5a15147b7b1014a1"><div class="ttname"><a href="group__Mesh.html#gad8284631ae078f8f5a15147b7b1014a1">HArDCore3D::Face::measure</a></div><div class="ttdeci">double measure() const</div><div class="ttdoc">measure of the face </div><div class="ttdef"><b>Definition:</b> face.hpp:114</div></div>
<div class="ttc" id="classHArDCore3D_1_1HHO__LocVarDiff_html_aba48f23cd9e46ab3b0d7d907e0990bd6"><div class="ttname"><a href="classHArDCore3D_1_1HHO__LocVarDiff.html#aba48f23cd9e46ab3b0d7d907e0990bd6">HArDCore3D::HHO_LocVarDiff::tensor_function_type</a></div><div class="ttdeci">std::function&lt; Eigen::Matrix3d(double, double, double, Cell *)&gt; tensor_function_type</div><div class="ttdoc">type for diffusion tensor </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:68</div></div>
<div class="ttc" id="group__HybridCore_html_ga94fa97198237f40a378a384f3d072394"><div class="ttname"><a href="group__HybridCore.html#ga94fa97198237f40a378a384f3d072394">HArDCore3D::HybridCore::nlocal_face_dofs</a></div><div class="ttdeci">size_t nlocal_face_dofs() const</div><div class="ttdoc">number of degrees of freedom on each face (dimension of polynomial space) </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:442</div></div>
<div class="ttc" id="group__HybridCore_html_gad9c2ba4cdbfda183ee00ab059d8885e5"><div class="ttname"><a href="group__HybridCore.html#gad9c2ba4cdbfda183ee00ab059d8885e5">HArDCore3D::ElementQuad::get_phiF_quadF</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXd &gt; get_phiF_quadF(size_t ilF) const</div><div class="ttdoc">Returns values of faces basis functions at face quadrature rules on face with local number ilF...</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:121</div></div>
<div class="ttc" id="group__HHO__LocVarDiff_html_ga4232eab7b9753215b506d5ce701c4f4f"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga4232eab7b9753215b506d5ce701c4f4f">HArDCore3D::HHO_LocVarDiff::get_assembly_time</a></div><div class="ttdeci">double get_assembly_time() const</div><div class="ttdoc">cpu time to assemble the scheme </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:640</div></div>
<div class="ttc" id="group__Mesh_html_ga805584b31ee6aa7f6725075d8d16a744"><div class="ttname"><a href="group__Mesh.html#ga805584b31ee6aa7f6725075d8d16a744">HArDCore3D::Cell::n_faces</a></div><div class="ttdeci">size_t n_faces() const</div><div class="ttdoc">returns number of faces of the cell </div><div class="ttdef"><b>Definition:</b> cell.hpp:123</div></div>
<div class="ttc" id="classHArDCore3D_1_1HybridCore_html_a06825c5d156026d465a2798389aa952b"><div class="ttname"><a href="classHArDCore3D_1_1HybridCore.html#a06825c5d156026d465a2798389aa952b">HArDCore3D::HybridCore::compute_weights</a></div><div class="ttdeci">Eigen::VectorXd compute_weights(size_t iT) const</div><div class="ttdoc">Weights to compute cell unknowns from face unknowns when l=-1. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:480</div></div>
<div class="ttc" id="group__HHO__LocVarDiff_html_ga498c8ed6193d76926ca3f3627ed6cf11"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga498c8ed6193d76926ca3f3627ed6cf11">HArDCore3D::HHO_LocVarDiff::HHO_LocVarDiff</a></div><div class="ttdeci">HHO_LocVarDiff(tensor_function_type kappa, size_t deg_kappa, source_function_type source, size_t BC, solution_function_type exact_solution, grad_function_type grad_exact_solution, std::string solver_type)</div><div class="ttdoc">Constructor of the class. </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:118</div></div>
<div class="ttc" id="group__HybridCore_html_ga9676c87f42764a058c9d7aecd2ce44cd"><div class="ttname"><a href="group__HybridCore.html#ga9676c87f42764a058c9d7aecd2ce44cd">HArDCore3D::ElementQuad::get_quadT</a></div><div class="ttdeci">QuadratureRule get_quadT() const</div><div class="ttdoc">Returns quadrature rules in cell. </div><div class="ttdef"><b>Definition:</b> elementquad.hpp:116</div></div>
<div class="ttc" id="group__HHO__LocVarDiff_html_ga10971b2952ab54d336127a43f5ed9b29"><div class="ttname"><a href="group__HHO__LocVarDiff.html#ga10971b2952ab54d336127a43f5ed9b29">HArDCore3D::HHO_LocVarDiff::get_solving_time</a></div><div class="ttdeci">double get_solving_time() const</div><div class="ttdoc">cpu time to solve the scheme </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:644</div></div>
<div class="ttc" id="group__HybridCore_html_gaddeb59cc8b5d89525e27b2dee22eb70f"><div class="ttname"><a href="group__HybridCore.html#gaddeb59cc8b5d89525e27b2dee22eb70f">HArDCore3D::HybridCore::nboundary_face_dofs</a></div><div class="ttdeci">size_t nboundary_face_dofs() const</div><div class="ttdoc">total number of face degrees of freedom for boundary faces </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:448</div></div>
<div class="ttc" id="group__Mesh_html_gab401dd009e7f13008b03cc2080d93449"><div class="ttname"><a href="group__Mesh.html#gab401dd009e7f13008b03cc2080d93449">HArDCore3D::Cell::is_boundary</a></div><div class="ttdeci">bool is_boundary() const</div><div class="ttdoc">returns true if cell touches the boundary </div><div class="ttdef"><b>Definition:</b> cell.hpp:119</div></div>
<div class="ttc" id="classHArDCore3D_1_1HybridCore_html_a02b46a742045262030431b73eb112f9c"><div class="ttname"><a href="classHArDCore3D_1_1HybridCore.html#a02b46a742045262030431b73eb112f9c">HArDCore3D::HybridCore::restr</a></div><div class="ttdeci">Eigen::VectorXd restr(const Eigen::VectorXd &amp;Xh, size_t iT) const</div><div class="ttdoc">Extract from a global vector Xh of unknowns the unknowns corresponding to cell iT. </div><div class="ttdef"><b>Definition:</b> hybridcore.cpp:506</div></div>
<div class="ttc" id="group__HybridCore_html_gab6349fe3a8eb0d4070cd2bd82742bdcc"><div class="ttname"><a href="group__HybridCore.html#gab6349fe3a8eb0d4070cd2bd82742bdcc">HArDCore3D::ElementQuad::get_phiT_quadF</a></div><div class="ttdeci">std::vector&lt; Eigen::ArrayXd &gt; get_phiT_quadF(size_t ilF) const</div><div class="ttdoc">Returns values of cell basis functions at cell quadrature rules on face with local number ilF...</div><div class="ttdef"><b>Definition:</b> elementquad.hpp:120</div></div>
<div class="ttc" id="group__HybridCore_html_ga907fd6e5325465e94acc67c831a14cdf"><div class="ttname"><a href="group__HybridCore.html#ga907fd6e5325465e94acc67c831a14cdf">HArDCore3D::HybridCore::Ldeg</a></div><div class="ttdeci">int Ldeg() const</div><div class="ttdoc">usually equal to L, but put at 0 if L=-1 </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:454</div></div>
<div class="ttc" id="classHArDCore3D_1_1ElementQuad_html"><div class="ttname"><a href="classHArDCore3D_1_1ElementQuad.html">HArDCore3D::ElementQuad</a></div><div class="ttdef"><b>Definition:</b> elementquad.hpp:53</div></div>
<div class="ttc" id="group__HybridCore_html_gad4c32f117a1e67ec4a13dd9656c404e8"><div class="ttname"><a href="group__HybridCore.html#gad4c32f117a1e67ec4a13dd9656c404e8">HArDCore3D::HybridCore::get_mesh_ptr</a></div><div class="ttdeci">const Mesh * get_mesh_ptr() const</div><div class="ttdoc">returns a pointer to the mesh </div><div class="ttdef"><b>Definition:</b> hybridcore.hpp:451</div></div>
<div class="ttc" id="group__HHO__LocVarDiff_html_gae66d0e79903e2ca077ff2515c20d7d2e"><div class="ttname"><a href="group__HHO__LocVarDiff.html#gae66d0e79903e2ca077ff2515c20d7d2e">HArDCore3D::HHO_LocVarDiff::get_itime</a></div><div class="ttdeci">double get_itime(size_t idx) const</div><div class="ttdoc">various intermediate assembly times </div><div class="ttdef"><b>Definition:</b> HHO_LocVarDiff.hpp:648</div></div>
<div class="ttc" id="classHArDCore3D_1_1Cell_html_ae994179c36e882c6a9a6e80e9477bbb5"><div class="ttname"><a href="classHArDCore3D_1_1Cell.html#ae994179c36e882c6a9a6e80e9477bbb5">HArDCore3D::Cell::face</a></div><div class="ttdeci">Face * face(size_t iL) const</div><div class="ttdoc">returns the iL-th face of the cell </div><div class="ttdef"><b>Definition:</b> cell.cpp:50</div></div>
<div class="ttc" id="classHArDCore3D_1_1Cell_html_a648c17f293071f01180c4014adb5a25b"><div class="ttname"><a href="classHArDCore3D_1_1Cell.html#a648c17f293071f01180c4014adb5a25b">HArDCore3D::Cell::face_normal</a></div><div class="ttdeci">Vector3d face_normal(size_t i) const</div><div class="ttdoc">returns the outer normal to the i-th face </div><div class="ttdef"><b>Definition:</b> cell.cpp:118</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
